{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///musquito-1.0.2.min.js","webpack:///webpack/bootstrap fb0840691fc92f5cb921","webpack:///./src/Utility.js","webpack:///./src/Emitter.js","webpack:///./src/Engine.js","webpack:///./src/Loader.js","webpack:///./src/Queue.js","webpack:///./src/Heap.js","webpack:///./src/Sound.js","webpack:///./src/Buzz.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Utility","_navigator","_contextType","_formats","_isAudioEnabled","navigator","AudioContext","webkitAudioContext","audio","Audio","mp3","Boolean","canPlayType","replace","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","Math","round","Date","now","random","format","formats","_this","find","isFormatSupported","source","ext","isBase64","exec","toLowerCase","sources","_this2","isSourceSupported","str","test","context","_isMobile","_isTouch","unlock","bufferSource","createBufferSource","buffer","createBuffer","connect","destination","cleanUp","document","removeEventListener","disconnect","addEventListener","start","noteOn","userAgent","window","maxTouchPoints","msMaxTouchPoints","default","Emitter","_objectsEventsHandlersMap","id","eventName","handler","once","arguments","undefined","_hasObject","objEvents","push","_hasEvent","filter","eventSubscriber","_len","args","Array","_key","eventSubscribers","setTimeout","subscriber","off","bind","_interopRequireDefault","obj","ErrorType","EngineEvents","EngineState","_Loader","_Loader2","_Emitter","_Emitter2","_Heap","_Heap2","_Queue","_Queue2","_Utility","_Utility2","_Sound","_Sound2","NoAudio","LoadError","PlayError","EngineError","NotReady","Ready","Suspending","Suspended","Resuming","Destroying","Done","Add","Remove","Volume","Mute","Pause","Stop","Suspend","Resume","Error","Engine","_id","_muted","_volume","_cleanUpInterval","_intervalId","_isAudioAvailable","_state","_context","_gainNode","_queue","_heap","_loader","getContext","_fire","type","error","_ref","volume","muted","cleanUpInterval","onadd","onremove","onstop","onpause","onmute","onvolume","onsuspend","onresume","onerror","ondone","on","enableAudio","createGain","gain","setValueAtTime","currentTime","setInterval","free","urls","load","unload","vol","sounds","forEach","sound","stop","add","suspend","then","run","resume","_this3","clearInterval","destroy","dispose","clear","remove","terminate","close","idOrUrl","groupId","_gain","idle","fire","apply","concat","engine","DownloadStatus","DownloadResult","Success","Failure","url","status","Loader","_bufferCache","_progressCallsAndCallbacks","_disposed","_load","Promise","all","map","_unload","isArray","resolve","reject","err","r","decodeAudioData","arrayBuffer","data","atob","split","dataView","Uint8Array","charCodeAt","req","XMLHttpRequest","open","responseType","response","send","Queue","_eventActions","actionIdentifier","action","removeAfterRun","hasEvent","fn","hasAction","_run","keys","queued","_toConsumableArray","arr","arr2","from","HeapItem","HeapItemCollection","items","soundId","toString","values","item","soundGroupId","isPlaying","isPaused","itemsArray","Heap","_collections","col","SoundState","_Engine","_Engine2","Playing","Paused","Destroyed","Sound","_rate","_loop","_buffer","_bufferSourceNode","_duration","_startPos","_endPos","_currentPos","_rateSeek","_startTime","_playEndCallback","_destroyCallback","rate","loop","startPos","endPos","playEndCallback","destroyCallback","duration","seek","max","playbackRate","_setLoop","_destroyBufferNode","startTime","noteGrainOn","realTime","rateElapsed","pause","play","noteGrainOff","_onEnded","loopStart","loopEnd","_typeof","Symbol","iterator","constructor","BuzzState","BuzzEvents","Load","UnLoad","PlayStart","PlayEnd","Seek","Rate","Destroy","LoadState","NotLoaded","Loading","Loaded","Buzz","_src","_format","_sprite","_preload","_autoplay","_compatibleSrc","_loadState","_engine","setup","isAudioAvailable","src","sprite","autoplay","preload","onload","onunload","onplaystart","onplayend","onrate","onseek","ondestroy","isLoaded","getCompatibleSource","downloadResult","_onLoadFailure","indexOf","getSupportedFormat","getSupportedSource","soundOrId","isIdPassed","newSoundId","playSound","soundArgs","positions","newSound","_sounds","mute","unmute","state","$buzz","method","result"],"mappings":"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","file":"musquito-1.0.2.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$buzz\"] = factory();\n\telse\n\t\troot[\"$buzz\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n*  musquito v1.0.0 \n*  http://musquitojs.com\n*\n*  (c) 2018 Vijaya Anand\n*  http://prideparrot.com\n*\n*  MIT License\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$buzz\"] = factory();\n\telse\n\t\troot[\"$buzz\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Contains helper methods.\n */\nvar Utility = function () {\n\n  /**\n   * @constructor\n   */\n\n\n  /**\n   * Dictionary of audio formats and their support status.\n   * @type {object}\n   * @private\n   */\n\n\n  /**\n   * The navigator object.\n   * @type {Navigator}\n   * @private\n   */\n  function Utility() {\n    _classCallCheck(this, Utility);\n\n    this._navigator = null;\n    this._contextType = null;\n    this._formats = {};\n    this._isAudioEnabled = false;\n\n    if (typeof navigator !== 'undefined') {\n      this._navigator = navigator;\n    }\n\n    // Set the available Web Audio Context type available in browser.\n    if (typeof AudioContext !== 'undefined') {\n      this._contextType = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n      this._contextType = webkitAudioContext;\n    }\n\n    // Determine the supported audio formats.\n    var audio = new Audio();\n\n    this._formats = {\n      mp3: Boolean(audio.canPlayType('audio/mp3;').replace(/^no$/, '')),\n      mpeg: Boolean(audio.canPlayType('audio/mpeg;').replace(/^no$/, '')),\n      opus: Boolean(audio.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')),\n      ogg: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      oga: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      wav: Boolean(audio.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n      aac: Boolean(audio.canPlayType('audio/aac;').replace(/^no$/, '')),\n      caf: Boolean(audio.canPlayType('audio/x-caf;').replace(/^no$/, '')),\n      m4a: Boolean((audio.canPlayType('audio/x-m4a;') || audio.canPlayType('audio/m4a;') || audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      mp4: Boolean((audio.canPlayType('audio/x-mp4;') || audio.canPlayType('audio/mp4;') || audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      weba: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      webm: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      dolby: Boolean(audio.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, '')),\n      flac: Boolean((audio.canPlayType('audio/x-flac;') || audio.canPlayType('audio/flac;')).replace(/^no$/, ''))\n    };\n\n    audio = null;\n  }\n\n  /**\n   * Returns an unique id (credit: https://howlerjs.com).\n   * @return {number}\n   */\n\n\n  /**\n   * Is audio already enabled or not.\n   * @type {boolean}\n   * @private\n   */\n\n\n  /**\n   * The AudioContext type.\n   * @type {Function}\n   * @private\n   */\n\n\n  _createClass(Utility, [{\n    key: 'id',\n    value: function id() {\n      return Math.round(Date.now() * Math.random());\n    }\n\n    /**\n     * Returns the available context type.\n     * @return {Function}\n     */\n\n  }, {\n    key: 'getContextType',\n    value: function getContextType() {\n      return this._contextType;\n    }\n\n    /**\n     * Instantiates and returns the audio context.\n     * @return {AudioContext|webkitAudioContext}\n     */\n\n  }, {\n    key: 'getContext',\n    value: function getContext() {\n      return new this._contextType();\n    }\n\n    /**\n     * Returns the supported audio formats.\n     * @return {Object}\n     */\n\n  }, {\n    key: 'supportedFormats',\n    value: function supportedFormats() {\n      return this._formats;\n    }\n\n    /**\n     * Returns true if the passed format is supported.\n     * @param {string} format The audio format ex. \"mp3\"\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isFormatSupported',\n    value: function isFormatSupported(format) {\n      return Boolean(this._formats[format]);\n    }\n\n    /**\n     * Returns the first supported format from the passed array.\n     * @param {string[]} formats Array of audio formats\n     * @return {string}\n     */\n\n  }, {\n    key: 'getSupportedFormat',\n    value: function getSupportedFormat(formats) {\n      var _this = this;\n\n      return formats.find(function (format) {\n        return _this.isFormatSupported(format);\n      });\n    }\n\n    /**\n     * Returns true if the audio source is supported.\n     * @param {string} source The audio source url or base64 string\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isSourceSupported',\n    value: function isSourceSupported(source) {\n      var ext = this.isBase64(source) ? /^data:audio\\/([^;,]+);/i.exec(source) : /^.+\\.([^.]+)$/.exec(source);\n\n      ext = /^.+\\.([^.]+)$/.exec(source);\n      return ext ? this.isFormatSupported(ext[1].toLowerCase()) : false;\n    }\n\n    /**\n     * Returns the first supported audio source from the passed array.\n     * @param {string[]} sources Array of audio sources. The audio source could be either url or base64 string.\n     * @return {string}\n     */\n\n  }, {\n    key: 'getSupportedSource',\n    value: function getSupportedSource(sources) {\n      var _this2 = this;\n\n      return sources.find(function (source) {\n        return _this2.isSourceSupported(source);\n      });\n    }\n\n    /**\n     * Returns whether the passed string is a base64 string or not.\n     * @param {string} str Base64 audio string\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isBase64',\n    value: function isBase64(str) {\n      return (/^data:[^;]+;base64,/.test(str)\n      );\n    }\n\n    /**\n     * Enables playing audio on first touch.\n     * @param {AudioContext} context Web API audio context.\n     */\n\n  }, {\n    key: 'enableAudio',\n    value: function enableAudio(context) {\n      if (!this._isMobile() && !this._isTouch() || this._isAudioEnabled) {\n        return;\n      }\n\n      var unlock = function unlock() {\n        var bufferSource = context.createBufferSource();\n        bufferSource.buffer = context.createBuffer(1, 1, 22050);\n        bufferSource.connect(context.destination);\n\n        var cleanUp = function cleanUp() {\n          document.removeEventListener('touchend', unlock);\n          bufferSource.disconnect();\n          bufferSource.removeEventListener('ended', cleanUp);\n          bufferSource = null;\n        };\n\n        bufferSource.addEventListener('ended', cleanUp);\n\n        if (typeof bufferSource.start === 'undefined') {\n          bufferSource.noteOn(0);\n        } else {\n          bufferSource.start(0);\n        }\n      };\n\n      document.addEventListener('touchend', unlock);\n    }\n\n    /**\n     * Returns true if the platform is mobile.\n     * @return {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_isMobile',\n    value: function _isMobile() {\n      if (!this._navigator) {\n        return false;\n      }\n\n      return (/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(this._navigator.userAgent)\n      );\n    }\n\n    /**\n     * Returns true if the platform is touch supported.\n     * @return {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_isTouch',\n    value: function _isTouch() {\n      return typeof window !== 'undefined' && Boolean('ontouchend' in window || this._navigator && this._navigator.maxTouchPoints > 0 || this._navigator && this._navigator.msMaxTouchPoints > 0);\n    }\n  }]);\n\n  return Utility;\n}();\n\nexports.default = new Utility();\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Singleton global event emitter.\n * @class\n */\nvar Emitter = function () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n\n    this._objectsEventsHandlersMap = {};\n  }\n\n  /**\n   * Dictionary that maps the objects with their events and handlers.\n   * @type {object}\n   * @private\n   */\n\n\n  _createClass(Emitter, [{\n    key: \"on\",\n\n\n    /**\n     * Subscribes to an event of the passed object.\n     * @param {number} id The unique id of the object.\n     * @param {string} eventName Name of the event\n     * @param {function} handler The event-handler function\n     * @param {boolean} [once = false] Is it one-time subscription or not?\n     * @return {Emitter}\n     */\n    value: function on(id, eventName, handler) {\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!this._hasObject(id)) {\n        this._objectsEventsHandlersMap[id] = {};\n      }\n\n      var objEvents = this._objectsEventsHandlersMap[id];\n\n      if (!objEvents.hasOwnProperty(eventName)) {\n        objEvents[eventName] = [];\n      }\n\n      objEvents[eventName].push({\n        handler: handler,\n        once: once\n      });\n\n      return this;\n    }\n\n    /**\n     * Un-subscribes from an event of the passed object.\n     * @param {number} id The unique id of the object.\n     * @param {string} eventName The event name.\n     * @param {function} [handler] The handler function.\n     * @return {Emitter}\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(id, eventName, handler) {\n      if (!this._hasEvent(id, eventName)) {\n        return this;\n      }\n\n      var objEvents = this._objectsEventsHandlersMap[id];\n\n      if (!handler) {\n        objEvents[eventName] = [];\n      } else {\n        objEvents[eventName] = objEvents[eventName].filter(function (eventSubscriber) {\n          return eventSubscriber.handler !== handler;\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Fires an event of the object passing the source and other optional arguments.\n     * @param {number} id The unique id of the object.\n     * @param {string} eventName The event name\n     * @param {...*} args The arguments that to be passed to handler\n     * @return {Emitter}\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(id, eventName) {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      if (!this._hasEvent(id, eventName)) {\n        return this;\n      }\n\n      var eventSubscribers = this._objectsEventsHandlersMap[id][eventName];\n\n      for (var i = 0; i < eventSubscribers.length; i++) {\n        var eventSubscriber = eventSubscribers[i];\n\n        setTimeout(function (subscriber) {\n          var handler = subscriber.handler,\n              once = subscriber.once;\n\n\n          handler.apply(undefined, args);\n\n          if (once) {\n            this.off(id, eventName, handler);\n          }\n        }.bind(this, eventSubscriber), 0);\n      }\n\n      return this;\n    }\n\n    /**\n     * Clears the event handlers of the passed object.\n     * @param {number} [id] The unique id of the object.\n     * @return {Emitter}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(id) {\n      if (!id) {\n        this._objectsEventsHandlersMap = {};\n        return this;\n      }\n\n      if (this._hasObject(id)) {\n        delete this._objectsEventsHandlersMap[id];\n      }\n\n      return this;\n    }\n\n    /**\n     * Returns true if the object is already registered.\n     * @param {number} id The object id.\n     * @return {boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_hasObject\",\n    value: function _hasObject(id) {\n      return this._objectsEventsHandlersMap.hasOwnProperty(id);\n    }\n\n    /**\n     * Returns true if the passed object has an entry of the passed event.\n     * @param {number} id The object id.\n     * @param {string} eventName The event name.\n     * @return {boolean}\n     * @private\n     */\n\n  }, {\n    key: \"_hasEvent\",\n    value: function _hasEvent(id, eventName) {\n      return this._hasObject(id) && this._objectsEventsHandlersMap[id].hasOwnProperty(eventName);\n    }\n  }]);\n\n  return Emitter;\n}();\n\nexports.default = new Emitter();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorType = exports.EngineEvents = exports.EngineState = exports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Loader = __webpack_require__(3);\n\nvar _Loader2 = _interopRequireDefault(_Loader);\n\nvar _Emitter = __webpack_require__(1);\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nvar _Heap = __webpack_require__(5);\n\nvar _Heap2 = _interopRequireDefault(_Heap);\n\nvar _Queue = __webpack_require__(4);\n\nvar _Queue2 = _interopRequireDefault(_Queue);\n\nvar _Utility = __webpack_require__(0);\n\nvar _Utility2 = _interopRequireDefault(_Utility);\n\nvar _Sound = __webpack_require__(6);\n\nvar _Sound2 = _interopRequireDefault(_Sound);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum that represents the different type of errors thrown by Engine and Buzzes.\n * @enum {string}\n */\nvar ErrorType = {\n  NoAudio: 'no-audio',\n  LoadError: 'load',\n  PlayError: 'play',\n  EngineError: 'engine'\n};\n\n/**\n * Represents the different states of the audio engine.\n * @enum {string}\n */\nvar EngineState = {\n  NotReady: 'notready',\n  Ready: 'ready',\n  Suspending: 'suspending',\n  Suspended: 'suspended',\n  Resuming: 'resuming',\n  Destroying: 'destroying',\n  Done: 'done',\n  NoAudio: 'no-audio'\n};\n\n/**\n * Enum that represents the different events by engine.\n * @enum {string}\n */\nvar EngineEvents = {\n  Add: 'add',\n  Remove: 'remove',\n  Volume: 'volume',\n  Mute: 'mute',\n  Pause: 'pause',\n  Stop: 'stop',\n  Suspend: 'suspend',\n  Resume: 'resume',\n  Error: 'error',\n  Done: 'done'\n};\n\n/**\n * The audio engine that orchestrates all the sounds.\n * @class\n */\n\nvar Engine = function () {\n\n  /**\n   * Instantiates the heap and action queue.\n   * @constructor\n   */\n\n\n  /**\n   * The sound heap.\n   * @type {Heap}\n   * @private\n   */\n\n\n  /**\n   * The master gain node.\n   * @type {GainNode}\n   * @private\n   */\n\n\n  /**\n   * Represents the current state of the engine.\n   * @type {EngineState}\n   * @private\n   */\n\n\n  /**\n   * The clean-up interval id.\n   * @type {number|null}\n   * @private\n   */\n\n\n  /**\n   * Represents the global volume.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * Unique id of the engine.\n   * @type {number}\n   * @private\n   */\n  function Engine() {\n    _classCallCheck(this, Engine);\n\n    this._id = _Utility2.default.id();\n    this._muted = false;\n    this._volume = 1.0;\n    this._cleanUpInterval = 5;\n    this._intervalId = null;\n    this._isAudioAvailable = false;\n    this._state = EngineState.NotReady;\n    this._context = null;\n    this._gainNode = null;\n    this._queue = null;\n    this._heap = null;\n    this._loader = null;\n\n    this._heap = new _Heap2.default();\n    this._queue = new _Queue2.default();\n  }\n\n  /**\n   * Instantiate the audio context and other dependencies.\n   * @param {object} [args] Input parameters object.\n   * @param {number} [args.volume = 1.0] The global volume of the sound engine.\n   * @param {boolean} [args.muted = false] Stay muted initially or not.\n   * @param {number} [args.cleanUpInterval = 5] The heap clean-up interval period in minutes.\n   * @param {function} [args.onadd] Event-handler for the \"add\" event.\n   * @param {function} [args.onremove] Event-handler for the \"remove\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onsuspend] Event-handler for the \"suspend\" event.\n   * @param {function} [args.onresume] Event-handler for the \"resume\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondone] Event-handler for the \"done\" event.\n   * @return {Engine}\n   */\n\n\n  /**\n   * Loader - the component that loads audio buffers with audio data.\n   * @type {Loader}\n   * @private\n   */\n\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n\n\n  /**\n   * The Web Audio API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n\n\n  /**\n   * True if Web Audio API is available.\n   * @type {boolean}\n   * @private\n   */\n\n\n  /**\n   * The heap clean-up period.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * Represents whether the audio engine is currently muted or not.\n   * @type {boolean}\n   * @private\n   */\n\n\n  _createClass(Engine, [{\n    key: 'setup',\n    value: function setup(args) {\n      // If the setup is already done return.\n      if (this._state !== EngineState.NotReady) {\n        return this;\n      }\n\n      this._context = _Utility2.default.getContext();\n\n      // Determine the audio stuff available in the current platform and set the flags accordingly.\n      this._isAudioAvailable = Boolean(this._context);\n\n      // If no Web Audio and HTML5 audio is available fire an error event.\n      if (!this._isAudioAvailable) {\n        this._state = EngineState.NoAudio;\n        this._fire(EngineEvents.Error, { type: ErrorType.NoAudio, error: 'Web Audio API is not available' });\n        return this;\n      }\n\n      // Read the input parameters from the options.\n\n      var _ref = args || {},\n          volume = _ref.volume,\n          muted = _ref.muted,\n          cleanUpInterval = _ref.cleanUpInterval,\n          onadd = _ref.onadd,\n          onremove = _ref.onremove,\n          onstop = _ref.onstop,\n          onpause = _ref.onpause,\n          onmute = _ref.onmute,\n          onvolume = _ref.onvolume,\n          onsuspend = _ref.onsuspend,\n          onresume = _ref.onresume,\n          onerror = _ref.onerror,\n          ondone = _ref.ondone;\n\n      // Set the properties from the read parameters.\n\n\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof cleanUpInterval === 'number' && (this._cleanUpInterval = cleanUpInterval);\n      typeof onadd === 'function' && this.on(EngineEvents.Add, onadd);\n      typeof onremove === 'function' && this.on(EngineEvents.Remove, onremove);\n      typeof onstop === 'function' && this.on(EngineEvents.Stop, onstop);\n      typeof onpause === 'function' && this.on(EngineEvents.Pause, onpause);\n      typeof onmute === 'function' && this.on(EngineEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(EngineEvents.Volume, onvolume);\n      typeof onsuspend === 'function' && this.on(EngineEvents.Suspend, onsuspend);\n      typeof onresume === 'function' && this.on(EngineEvents.Resume, onresume);\n      typeof onerror === 'function' && this.on(EngineEvents.Error, onerror);\n      typeof ondone === 'function' && this.on(EngineEvents.Done, ondone);\n\n      // Create the buffer loader.\n      this._loader = new _Loader2.default(this._context);\n\n      // Auto-enable audio for the mobile devices in the first touch.\n      _Utility2.default.enableAudio(this._context);\n\n      // Create the audio graph.\n      this._gainNode = this._context.createGain();\n      this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n      this._gainNode.connect(this._context.destination);\n\n      this._intervalId = window.setInterval(this._heap.free, this._cleanUpInterval * 60 * 1000);\n\n      this._state = EngineState.Ready;\n\n      return this;\n    }\n\n    /**\n     * Loads single or multiple audio resources into audio buffers and returns them.\n     * @param {string|string[]} urls Single or array of audio urls.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'load',\n    value: function load(urls) {\n      return this._loader.load(urls);\n    }\n\n    /**\n     * Unloads single or multiple loaded audio buffers from cache.\n     * @param {string|string[]} [urls] Single or array of audio urls.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'unload',\n    value: function unload(urls) {\n      this._loader.unload(urls);\n      return this;\n    }\n\n    /**\n     * Mutes the engine.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      // If the engine is already muted return.\n      if (this._muted) {\n        return this;\n      }\n\n      // Set the value of gain node to 0.\n      this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n      // Set the muted property true.\n      this._muted = true;\n\n      // Fire the \"mute\" event.\n      this._fire(EngineEvents.Mute, this._muted);\n\n      return this;\n    }\n\n    /**\n     * Un-mutes the engine.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      // If the engine is not muted return.\n      if (!this._muted) {\n        return this;\n      }\n\n      // Reset the gain node's value back to volume.\n      this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n      // Set the muted property to false.\n      this._muted = false;\n\n      // Fire the \"mute\" event.\n      this._fire(EngineEvents.Mute, this._muted);\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the volume for the audio engine that controls global volume for all sounds.\n     * @param {number} [vol] Should be within 0.0 to 1.0.\n     * @return {Engine|number}\n     */\n\n  }, {\n    key: 'volume',\n    value: function volume(vol) {\n      // If no parameter is passed then return the current volume.\n      if (vol === undefined) {\n        return this._volume;\n      }\n\n      // If passed volume is not an acceptable value return.\n      if (typeof vol !== 'number' || vol < 0 || vol > 1.0) {\n        return this;\n      }\n\n      // Set the gain's value to the passed volume.\n      this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n      // Set the volume to the property.\n      this._volume = vol;\n\n      // Fire the \"volume\" event.\n      this._fire(EngineEvents.Volume, this._volume);\n\n      return this;\n    }\n\n    /**\n     * Stops all the currently playing sounds.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      // Stop all the sounds.\n      this._heap.sounds().forEach(function (sound) {\n        return sound.stop();\n      });\n\n      // Fire the \"stop\" event.\n      this._fire(EngineEvents.Stop);\n\n      return this;\n    }\n\n    /**\n     * Stops all the playing sounds and suspends the audio context immediately.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'suspend',\n    value: function suspend() {\n      var _this = this;\n\n      // If the context is resuming then suspend after resumed.\n      if (this._state === EngineState.Resuming) {\n        this._queue.add('after-resume', 'suspend', function () {\n          return _this.suspend();\n        });\n        return this;\n      }\n\n      // If the state is not ready return.\n      if (this._state !== EngineState.Ready) {\n        return this;\n      }\n\n      // Stop all the playing sounds.\n      this.stop();\n\n      // Set the state to suspending.\n      this._state = EngineState.Suspending;\n\n      // Suspend the Audio Context.\n      this._context.suspend().then(function () {\n        _this._state = EngineState.Suspended;\n        _this._queue.run('after-suspend');\n        _this._fire(EngineEvents.Suspend);\n      });\n\n      return this;\n    }\n\n    /**\n     * Resumes the audio context from the suspended mode.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'resume',\n    value: function resume() {\n      var _this2 = this;\n\n      // If the context is suspending then resume after suspended.\n      if (this._state === EngineState.Suspending) {\n        this._queue.add('after-suspend', 'resume', function () {\n          return _this2.resume();\n        });\n        return this;\n      }\n\n      if (!this._state !== EngineState.Suspended) {\n        return this;\n      }\n\n      this._state = EngineState.Resuming;\n\n      this._context.resume().then(function () {\n        _this2._state = EngineState.Ready;\n        _this2._queue.run('after-resume');\n        _this2._fire(EngineEvents.Resume);\n      });\n\n      return this;\n    }\n\n    /**\n     * Shuts down the engine.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      var _this3 = this;\n\n      if (this._state === EngineState.Done || this._state === EngineState.Destroying) {\n        return this;\n      }\n\n      var cleanUp = function cleanUp() {\n        // Stop the timer.\n        _this3._intervalId && window.clearInterval(_this3._intervalId);\n        _this3._intervalId = null;\n\n        // Destroy the heap.\n        _this3._heap.destroy();\n        _this3._heap = null;\n\n        // Clear the cache and remove the loader.\n        if (_this3._loader) {\n          _this3._loader.dispose();\n          _this3._loader = null;\n        }\n\n        _this3._context = null;\n        _this3._queue.clear();\n        _this3._queue = null;\n        _this3._state = EngineState.Done;\n\n        // Fire the \"done\" event.\n        _this3._fire(EngineEvents.Done);\n\n        _Emitter2.default.clear(_this3._id);\n      };\n\n      // Close the context.\n      if (this._context) {\n        if (this._state === EngineState.Suspending) {\n          this._queue.remove('after-suspend');\n          this._queue.add('after-suspend', 'destroy', function () {\n            return _this3.terminate();\n          });\n          return this;\n        } else if (this._state === EngineState.Resuming) {\n          this._queue.remove('after-resume');\n          this._queue.add('after-resume', 'destroy', function () {\n            return _this3.terminate();\n          });\n          return this;\n        }\n\n        this._state = EngineState.Destroying;\n        this._context && this._context.close().then(function () {\n          return cleanUp();\n        });\n      } else {\n        this._state = EngineState.Destroying;\n        cleanUp();\n      }\n\n      return this;\n    }\n\n    /**\n     * Subscribes to an event.\n     * @param {string} eventName Name of the event.\n     * @param {function} handler The event-handler function.\n     * @param {boolean} [once = false] Is it one-time subscription or not.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(eventName, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      _Emitter2.default.on(this._id, eventName, handler, once);\n      return this;\n    }\n\n    /**\n     * Un-subscribes from an event.\n     * @param {string} eventName The event name.\n     * @param {function} [handler] The handler function.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(eventName, handler) {\n      _Emitter2.default.off(this._id, eventName, handler);\n      return this;\n    }\n\n    /**\n     * Returns the existing sound in heap or create a new one and return.\n     * @param {number|string} idOrUrl The sound id or audio url/base64 string.\n     * @param {number} [groupId] The group id.\n     * @param {object} [args] The sound creation arguments.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'sound',\n    value: function sound(idOrUrl, groupId, args) {\n      if (typeof idOrUrl === 'number') {\n        return this._heap.sound(idOrUrl);\n      }\n\n      var sound = new _Sound2.default(args);\n      this._heap.add(idOrUrl, groupId, sound);\n      sound._gain().connect(this._gainNode);\n\n      return sound;\n    }\n\n    /**\n     * Returns the sounds belongs to a group or all the sounds from the heap.\n     * @param {number} [groupId] The group id.\n     * @return {Array<Sound>}\n     */\n\n  }, {\n    key: 'sounds',\n    value: function sounds(groupId) {\n      return this._heap.sounds(groupId);\n    }\n\n    /**\n     * Destroys the sounds belong to the passed group.\n     * @param {boolean} idle True to destroy only the idle sounds.\n     * @param {number} groupId The group id.\n     * @return {Engine}\n     */\n\n  }, {\n    key: 'free',\n    value: function free(idle, groupId) {\n      this._heap.free(idle, groupId);\n      return this;\n    }\n\n    /**\n     * Returns whether the engine is currently muted or not.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'muted',\n    value: function muted() {\n      return this._muted;\n    }\n\n    /**\n     * Returns the state of the engine.\n     * @return {EngineState}\n     */\n\n  }, {\n    key: 'state',\n    value: function state() {\n      return this._state;\n    }\n\n    /**\n     * Returns the created audio context.\n     * @return {AudioContext}\n     */\n\n  }, {\n    key: 'context',\n    value: function context() {\n      return this._context;\n    }\n\n    /**\n     * Returns true if Web Audio API is available.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isAudioAvailable',\n    value: function isAudioAvailable() {\n      return this._isAudioAvailable;\n    }\n\n    /**\n     * Fires an event of engine.\n     * @param {string} eventName The event name.\n     * @param {...*} args The arguments that to be passed to handler.\n     * @return {Engine}\n     * @private\n     */\n\n  }, {\n    key: '_fire',\n    value: function _fire(eventName) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      _Emitter2.default.fire.apply(_Emitter2.default, [this._id, eventName].concat(args, [this]));\n      return this;\n    }\n  }]);\n\n  return Engine;\n}();\n\nvar engine = new Engine();\nexports.default = engine;\nexports.EngineState = EngineState;\nexports.EngineEvents = EngineEvents;\nexports.ErrorType = ErrorType;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownloadStatus = exports.DownloadResult = exports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Utility = __webpack_require__(0);\n\nvar _Utility2 = _interopRequireDefault(_Utility);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum to represent the download status of audio resource.\n * @enum {string}\n */\nvar DownloadStatus = {\n  Success: 'success',\n  Failure: 'error'\n};\n\n/**\n * Represents the download result of an audio.\n * @class\n */\n\nvar DownloadResult =\n\n/**\n * @param {string|null} url The url of the audio resource\n * @param {AudioBuffer|Audio} [value] AudioBuffer or Html5Audio element\n * @param {*} [error] Download error\n */\n\n\n/**\n * Download error\n * @type {any}\n */\n\n\n/**\n * The url of the audio resource\n * @type {string|null}\n */\nfunction DownloadResult(url, value, error) {\n  _classCallCheck(this, DownloadResult);\n\n  this.url = null;\n  this.value = null;\n  this.error = null;\n  this.status = null;\n\n  this.url = url;\n  this.value = value;\n  this.error = error || null;\n  this.status = error ? DownloadStatus.Failure : DownloadStatus.Success;\n}\n\n/**\n * Success or failure status of download.\n * @type {DownloadStatus}\n */\n\n\n/**\n * AudioBuffer or Html5Audio element\n * @type {AudioBuffer|Audio}\n */\n;\n\n/**\n * Loads the audio sources into audio buffers and returns them.\n * The loaded buffers are cached.\n * @class\n */\n\n\nvar Loader = function () {\n\n  /**\n   * Create the cache.\n   * @param {AudioContext} context The Audio Context\n   */\n\n\n  /**\n   * Dictionary to store the current progress calls and their callbacks.\n   * @type {object}\n   * @private\n   */\n\n\n  /**\n   * AudioContext.\n   * @type {AudioContext}\n   * @private\n   */\n  function Loader(context) {\n    _classCallCheck(this, Loader);\n\n    this._context = null;\n    this._bufferCache = {};\n    this._progressCallsAndCallbacks = {};\n    this._disposed = false;\n\n    this._context = context;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers.\n   * @param {string|string[]} urls Single or array of audio urls\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n\n\n  /**\n   * In-memory audio buffer cache store.\n   * @type {object}\n   * @private\n   */\n\n\n  _createClass(Loader, [{\n    key: 'load',\n    value: function load(urls) {\n      var _this = this;\n\n      if (typeof urls === 'string') {\n        return this._load(urls);\n      }\n\n      return Promise.all(urls.map(function (url) {\n        return _this._load(url);\n      }));\n    }\n\n    /**\n     * Removes the cached audio buffers.\n     * @param {string|string[]} [urls] Single or array of audio urls\n     */\n\n  }, {\n    key: 'unload',\n    value: function unload(urls) {\n      var _this2 = this;\n\n      if (typeof urls === 'string') {\n        this._unload(urls);\n        return;\n      }\n\n      if (Array.isArray(urls)) {\n        urls.forEach(function (url) {\n          return _this2._unload(url);\n        }, this);\n        return;\n      }\n\n      this._bufferCache = {};\n    }\n\n    /**\n     * Dispose the loader.\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      if (this._disposed) {\n        return;\n      }\n\n      this.unload();\n      this._bufferCache = {};\n      this._progressCallsAndCallbacks = null;\n      this._context = null;\n      this._disposed = true;\n    }\n\n    /**\n     * Loads a single audio resource into audio buffer and cache result if the download is succeeded.\n     * @param {string} url The Audio url\n     * @return {Promise<DownloadResult>}\n     * @private\n     */\n\n  }, {\n    key: '_load',\n    value: function _load(url) {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        if (_this3._bufferCache.hasOwnProperty(url)) {\n          resolve(new DownloadResult(url, _this3._bufferCache[url]));\n          return;\n        }\n\n        if (_this3._progressCallsAndCallbacks.hasOwnProperty(url)) {\n          _this3._progressCallsAndCallbacks[url].push(resolve);\n          return;\n        }\n\n        _this3._progressCallsAndCallbacks[url] = [];\n        _this3._progressCallsAndCallbacks[url].push(resolve);\n\n        var reject = function reject(err) {\n          if (_this3._disposed) {\n            return;\n          }\n\n          _this3._progressCallsAndCallbacks[url].forEach(function (r) {\n            return r(new DownloadResult(url, null, err));\n          });\n          delete _this3._progressCallsAndCallbacks[url];\n        };\n\n        var decodeAudioData = function decodeAudioData(arrayBuffer) {\n          if (_this3._disposed) {\n            return;\n          }\n\n          _this3._context.decodeAudioData(arrayBuffer, function (buffer) {\n            _this3._bufferCache[url] = buffer;\n            _this3._progressCallsAndCallbacks[url].forEach(function (r) {\n              return r(new DownloadResult(url, buffer));\n            });\n            delete _this3._progressCallsAndCallbacks[url];\n          }, reject);\n        };\n\n        if (_Utility2.default.isBase64(url)) {\n          var data = atob(url.split(',')[1]);\n          var dataView = new Uint8Array(data.length); // eslint-disable-line no-undef\n\n          for (var i = 0; i < data.length; ++i) {\n            dataView[i] = data.charCodeAt(i);\n          }\n\n          decodeAudioData(dataView);\n          return;\n        }\n\n        var req = new XMLHttpRequest();\n        req.open('GET', url, true);\n        req.responseType = 'arraybuffer';\n\n        req.addEventListener('load', function () {\n          return decodeAudioData(req.response);\n        }, false);\n        req.addEventListener('error', reject, false);\n        req.send();\n      });\n    }\n\n    /**\n     * Removes the single cached audio buffer.\n     * @param {string} url Audio url\n     * @private\n     */\n\n  }, {\n    key: '_unload',\n    value: function _unload(url) {\n      delete this._bufferCache[url];\n    }\n  }]);\n\n  return Loader;\n}();\n\nexports.default = Loader;\nexports.DownloadResult = DownloadResult;\nexports.DownloadStatus = DownloadStatus;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Stores queue of actions that has to be run before or after specific events.\n */\nvar Queue = function () {\n  function Queue() {\n    _classCallCheck(this, Queue);\n\n    this._eventActions = {};\n  }\n\n  _createClass(Queue, [{\n    key: 'add',\n\n\n    /**\n     * Queues the passed action to the event.\n     * @param {string} eventName The event name.\n     * @param {string} actionIdentifier The action identifier.\n     * @param {function} action The action function.\n     * @param {boolean} [removeAfterRun = true] Remove the action once it's run.\n     */\n    value: function add(eventName, actionIdentifier, action) {\n      var removeAfterRun = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (!this.hasEvent(eventName)) {\n        this._eventActions[eventName] = {};\n      }\n\n      this._eventActions[eventName][actionIdentifier] = { fn: action, removeAfterRun: removeAfterRun };\n    }\n\n    /**\n     * Returns true if there is a event exists for the passed name.\n     * @param {string} eventName The event name.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'hasEvent',\n    value: function hasEvent(eventName) {\n      return this._eventActions.hasOwnProperty(eventName);\n    }\n\n    /**\n     * Returns true if the passed action is already queued-up.\n     * @param {string} eventName The event name.\n     * @param {string} actionIdentifier The action identifier.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'hasAction',\n    value: function hasAction(eventName, actionIdentifier) {\n      if (!this.hasEvent(eventName)) {\n        return false;\n      }\n\n      return this._eventActions[eventName].hasOwnProperty(actionIdentifier);\n    }\n\n    /**\n     * Runs all the actions queued up for the passed event.\n     * @param {string} eventName The event name.\n     * @param {string} [actionIdentifier] The action identifier.\n     */\n\n  }, {\n    key: 'run',\n    value: function run(eventName, actionIdentifier) {\n      var _this = this;\n\n      if (!this.hasEvent(eventName)) {\n        return;\n      }\n\n      if (typeof actionIdentifier !== 'undefined') {\n        if (!this.hasAction(eventName, actionIdentifier)) {\n          return;\n        }\n\n        this._run(eventName, actionIdentifier);\n\n        return;\n      }\n\n      Object.keys(this._eventActions[eventName]).forEach(function (action) {\n        return _this._run(eventName, action);\n      });\n    }\n\n    /**\n     * Removes the event or a queued action for the event.\n     * @param {string} eventName The event name.\n     * @param {string} [actionIdentifier] The action identifier.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(eventName, actionIdentifier) {\n      if (!this._eventActions.hasOwnProperty(eventName)) {\n        return;\n      }\n\n      if (!actionIdentifier) {\n        delete this._eventActions[eventName];\n        return;\n      }\n\n      delete this._eventActions[eventName][actionIdentifier];\n    }\n\n    /**\n     * Clears all the stored events and the queued-up actions.\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._eventActions = {};\n    }\n\n    /**\n     * Runs a single action.\n     * @param {string} eventName The event name.\n     * @param {string} actionIdentifier The action identifier.\n     * @private\n     */\n\n  }, {\n    key: '_run',\n    value: function _run(eventName, actionIdentifier) {\n      var queued = this._eventActions[eventName][actionIdentifier];\n      queued.fn();\n      queued.removeAfterRun && this.remove(eventName, actionIdentifier);\n    }\n  }]);\n\n  return Queue;\n}();\n\nexports.default = Queue;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Represents a heap item.\n */\nvar HeapItem =\n\n/**\n * Set the group id and sound.\n * @param {number} groupId The group id.\n * @param {Sound} sound The sound instance.\n */\n\n\n/**\n * The sound object.\n * @type {Sound}\n */\nfunction HeapItem(groupId, sound) {\n  _classCallCheck(this, HeapItem);\n\n  this.sound = null;\n  this.groupId = null;\n\n  this.groupId = groupId;\n  this.sound = sound;\n}\n\n/**\n * The group id.\n * @type {number|null}\n */\n;\n\n/**\n * Represents a collection of sounds belong to an audio resource.\n */\n\n\nvar HeapItemCollection = function () {\n  function HeapItemCollection() {\n    _classCallCheck(this, HeapItemCollection);\n\n    this.url = null;\n    this.items = {};\n  }\n\n  /**\n   * The audio source url.\n   * @type {string|null}\n   */\n\n\n  /**\n   * The collection of sound objects.\n   * @type {object}\n   */\n\n\n  _createClass(HeapItemCollection, [{\n    key: \"add\",\n\n\n    /**\n     * Adds a new sound item to the collection.\n     * @param {number} groupId The group id.\n     * @param {Sound} sound The sound instance.\n     */\n    value: function add(groupId, sound) {\n      var soundId = sound.id().toString();\n\n      if (this.items.hasOwnProperty(soundId)) {\n        return;\n      }\n\n      this.items[soundId] = new HeapItem(groupId, sound);\n    }\n\n    /**\n     * Removes the sounds.\n     * @param {boolean} [idle = true] True to destroy only the idle sounds.\n     * @param {number} [groupId] The group id.\n     */\n\n  }, {\n    key: \"free\",\n    value: function free() {\n      var _this = this;\n\n      var idle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var groupId = arguments[1];\n\n      Object.values(this.items).forEach(function (item) {\n        var sound = item.sound,\n            soundGroupId = item.soundGroupId;\n\n\n        if (idle && (sound.isPlaying() || sound.isPaused())) {\n          return;\n        }\n\n        if (!Boolean(groupId) || soundGroupId === groupId) {\n          sound.destroy();\n          delete _this.items[sound.id()];\n        }\n      });\n    }\n\n    /**\n     * Returns the sounds belong to the group or all the sounds in the collection.\n     * @param {number} [groupId] The group id.\n     * @return {Array<HeapItem>}\n     */\n\n  }, {\n    key: \"sounds\",\n    value: function sounds(groupId) {\n      var itemsArray = Object.values(this.items);\n      var items = groupId ? itemsArray.filter(function (item) {\n        return item.groupId === groupId;\n      }) : itemsArray;\n      return items.map(function (item) {\n        return item.sound;\n      });\n    }\n\n    /**\n     * Destroys all the sounds.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this.items).forEach(function (item) {\n        return item.sound.destroy();\n      });\n      this.items = {};\n    }\n  }]);\n\n  return HeapItemCollection;\n}();\n\n/**\n * Stores all the created sounds.\n */\n\n\nvar Heap = function () {\n\n  /**\n   * Initialize stuff.\n   */\n  function Heap() {\n    _classCallCheck(this, Heap);\n\n    this._collections = {};\n\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Adds a new sound to the respective collection.\n   * @param {string} url The audio source url or base64 string.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n\n\n  /**\n   * The sound collections.\n   * @type {object}\n   * @private\n   */\n\n\n  _createClass(Heap, [{\n    key: \"add\",\n    value: function add(url, groupId, sound) {\n      if (!this._collections.hasOwnProperty(url)) {\n        this._collections[url] = new HeapItemCollection();\n      }\n\n      this._collections[url].add(groupId, sound);\n    }\n\n    /**\n     * Returns the sound based on the id.\n     * @param {number} id The sound id.\n     */\n\n  }, {\n    key: \"sound\",\n    value: function sound(id) {\n      return this.sounds().find(function (sound) {\n        return sound.id() === id;\n      });\n    }\n\n    /**\n     * Returns the sounds belongs to a particular group or all of them.\n     * @param {number} [groupId] The group id.\n     * @return {Array}\n     */\n\n  }, {\n    key: \"sounds\",\n    value: function sounds(groupId) {\n      var sounds = [];\n      Object.values(this._collections).forEach(function (col) {\n        return sounds.push.apply(sounds, _toConsumableArray(col.sounds(groupId)));\n      });\n      return sounds;\n    }\n\n    /**\n     * Removes sounds from the collections.\n     * @param {boolean} [idle = true] True to destroy only the idle sounds.\n     * @param {number} [groupId] The group id.\n     */\n\n  }, {\n    key: \"free\",\n    value: function free() {\n      var idle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var groupId = arguments[1];\n\n      Object.values(this._collections).forEach(function (col) {\n        return col.free(idle, groupId);\n      });\n    }\n\n    /**\n     * Destroys all the sounds.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      Object.values(this._collections).forEach(function (col) {\n        return col.destroy();\n      });\n      this._collections = {};\n    }\n  }]);\n\n  return Heap;\n}();\n\nexports.default = Heap;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SoundState = exports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Engine = __webpack_require__(2);\n\nvar _Engine2 = _interopRequireDefault(_Engine);\n\nvar _Utility = __webpack_require__(0);\n\nvar _Utility2 = _interopRequireDefault(_Utility);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {string}\n */\nvar SoundState = {\n  Ready: 'ready',\n  Playing: 'playing',\n  Paused: 'paused',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Represents a sound created using Web Audio API.\n * @class\n */\n\nvar Sound = function () {\n\n  /**\n   * Initializes the internal properties of the sound.\n   * @param {object} args The input parameters of the sound.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {AudioBuffer} [args.buffer] Audio source buffer.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {number} [args.startPos] The playback start position.\n   * @param {number} [args.endPos] The playback end position.\n   * @param {function} [args.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [args.destroyCallback] The callback that will be invoked after destroyed.\n   * @constructor\n   */\n\n\n  /**\n   * The callback that will be invoked after the play ends.\n   * @type {function}\n   * @private\n   */\n\n\n  /**\n   * The position of the playback during rate change.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * The playback end position.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n\n\n  /**\n   * The current playback speed. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  function Sound(args) {\n    _classCallCheck(this, Sound);\n\n    this._id = -1;\n    this._volume = 1.0;\n    this._rate = 1;\n    this._muted = false;\n    this._loop = false;\n    this._state = SoundState.Ready;\n    this._context = null;\n    this._gainNode = null;\n    this._buffer = null;\n    this._bufferSourceNode = null;\n    this._duration = 0;\n    this._startPos = 0;\n    this._endPos = 0;\n    this._currentPos = 0;\n    this._rateSeek = 0;\n    this._startTime = 0;\n    this._playEndCallback = null;\n    this._destroyCallback = null;\n    var id = args.id,\n        buffer = args.buffer,\n        volume = args.volume,\n        rate = args.rate,\n        loop = args.loop,\n        muted = args.muted,\n        startPos = args.startPos,\n        endPos = args.endPos,\n        playEndCallback = args.playEndCallback,\n        destroyCallback = args.destroyCallback;\n\n    // Set the passed id or the random one.\n\n    this._id = typeof id === 'number' ? id : _Utility2.default.id();\n\n    // Set the passed audio buffer and duration.\n    this._buffer = buffer;\n    this._endPos = this._buffer.duration;\n\n    // Set other properties.\n    volume && (this._volume = volume);\n    rate && (this._rate = rate);\n    muted && (this._muted = muted);\n    loop && (this._loop = loop);\n    startPos && (this._startPos = startPos);\n    endPos && (this._endPos = endPos);\n    this._playEndCallback = playEndCallback;\n    this._destroyCallback = destroyCallback;\n\n    // Calculate the duration.\n    this._duration = this._endPos - this._startPos;\n\n    // Create gain node and set the volume.\n    this._context = _Engine2.default.context();\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n  }\n\n  /**\n   * Plays the sound or the sound defined in the sprite.\n   * @return {Sound}\n   */\n\n\n  /**\n   * The callback that will be invoked after the sound destroyed.\n   * @type {function}\n   * @private\n   */\n\n\n  /**\n   * The time at which the playback started.\n   * This property is required for getting the seek position of the playback.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * The current position of the playback.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * The playback start position.\n   * @type {number}\n   * @private\n   */\n\n\n  /**\n   * The AudioBufferSourceNode that plays the audio buffer assigned to it.\n   * @type {AudioBufferSourceNode}\n   * @private\n   */\n\n\n  /**\n   * The gain node to control the volume of the sound.\n   * @type {GainNode}\n   * @private\n   */\n\n\n  /**\n   * The current state (playing, paused etc.) of the sound.\n   * @type {SoundState}\n   * @private\n   */\n\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n\n\n  _createClass(Sound, [{\n    key: 'play',\n    value: function play() {\n      var _this = this;\n\n      // If the sound is already playing then return.\n      if (this.isPlaying()) {\n        return this;\n      }\n\n      // Get the playback starting position.\n      var seek = Math.max(0, this._currentPos > 0 ? this._currentPos : this._startPos);\n\n      // Create a new buffersourcenode to play the sound.\n      this._bufferSourceNode = this._context.createBufferSource();\n\n      // Set the buffer, playback rate and loop parameters\n      this._bufferSourceNode.buffer = this._buffer;\n      this._bufferSourceNode.playbackRate.setValueAtTime(this._rate, this._context.currentTime);\n      this._setLoop(this._loop);\n\n      // Connect the node to the audio graph.\n      this._bufferSourceNode.connect(this._gainNode);\n\n      // Listen to the \"ended\" event to reset/clean things.\n      this._bufferSourceNode.addEventListener('ended', function () {\n        // Reset the seek positions\n        _this._currentPos = 0;\n        _this._rateSeek = 0;\n\n        // Destroy the node (AudioBufferSourceNodes are one-time use and throw objects).\n        _this._destroyBufferNode();\n\n        // Reset the state to allow future actions.\n        _this._state = SoundState.Ready;\n\n        // Invoke the callback if there is one.\n        _this._playEndCallback && _this._playEndCallback(_this);\n      });\n\n      var startTime = this._context.currentTime;\n\n      // Call the supported method to play the sound.\n      if (typeof this._bufferSourceNode.start !== 'undefined') {\n        this._bufferSourceNode.start(startTime, seek, this._loop ? undefined : this._duration);\n      } else {\n        this._bufferSourceNode.noteGrainOn(startTime, seek, this._loop ? undefined : this._duration);\n      }\n\n      // Record the starting time and set the state.\n      this._startTime = startTime;\n      this._state = SoundState.Playing;\n\n      return this;\n    }\n\n    /**\n     * Pauses the playing sound.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      // If the sound is already playing return.\n      if (!this.isPlaying()) {\n        return this;\n      }\n\n      // Save the current position and reset rateSeek.\n      this._currentPos = this.seek();\n      this._rateSeek = 0;\n\n      this._destroyBufferNode();\n\n      this._state = SoundState.Paused;\n\n      return this;\n    }\n\n    /**\n     * Stops the sound that is playing or in paused state.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      // If the sound is not playing or paused return.\n      if (!this.isPlaying() && !this.isPaused()) {\n        return this;\n      }\n\n      // Reset the variables\n      this._currentPos = 0;\n      this._rateSeek = 0;\n\n      this._destroyBufferNode();\n\n      this._state = SoundState.Ready;\n\n      return this;\n    }\n\n    /**\n     * Mutes the sound.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      // Set the value of gain node to 0.\n      this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n      // Set the muted property true.\n      this._muted = true;\n\n      return this;\n    }\n\n    /**\n     * Un-mutes the sound.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      // Reset the gain node's value back to volume.\n      this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n      // Set the muted property to false.\n      this._muted = false;\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the volume.\n     * @param {number} [vol] Should be from 0.0 to 1.0.\n     * @return {Sound|number}\n     */\n\n  }, {\n    key: 'volume',\n    value: function volume(vol) {\n      // If no input parameter is passed then return the volume.\n      // If gain node is available read and return the value from it (helps in returning accurate value during fading)\n      // or else delegate that to the derived type.\n      if (typeof vol === 'undefined') {\n        return this._volume;\n      }\n\n      // Set the gain's value to the passed volume.\n      this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n      // Set the volume to the property.\n      this._volume = vol;\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the playback rate.\n     * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n     * @return {Sound|number}\n     */\n\n  }, {\n    key: 'rate',\n    value: function rate(_rate) {\n      // If no input parameter is passed return the current rate.\n      if (typeof _rate === 'undefined') {\n        return this._rate;\n      }\n\n      this._rate = _rate;\n      this._rateSeek = this.seek();\n\n      if (this.isPlaying()) {\n        this._startTime = this._context.currentTime;\n        this._bufferSourceNode && this._bufferSourceNode.playbackRate.setValueAtTime(_rate, this._context.currentTime);\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the seek position.\n     * @param {number} [seek] The seek position.\n     * @return {Sound|number}\n     */\n\n  }, {\n    key: 'seek',\n    value: function seek(_seek) {\n      // If no parameter is passed return the current position.\n      if (typeof _seek === 'undefined') {\n        var realTime = this.isPlaying() ? this._context.currentTime - this._startTime : 0;\n        var rateElapsed = this._rateSeek ? this._rateSeek - this._currentPos : 0;\n\n        return this._currentPos + (rateElapsed + realTime * this._rate);\n      }\n\n      // If seeking outside the borders then return.\n      if (_seek < this._startPos || _seek > this._endPos) {\n        return this;\n      }\n\n      // If the sound is currently playing... pause it, set the seek position and then continue playing.\n      var isPlaying = this.isPlaying();\n\n      if (isPlaying) {\n        this.pause();\n      }\n\n      this._currentPos = _seek;\n\n      if (isPlaying) {\n        this.play();\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the loop parameter of the sound.\n     * @param {boolean} [loop] True to loop the sound.\n     * @return {Sound/boolean}\n     */\n\n  }, {\n    key: 'loop',\n    value: function loop(_loop) {\n      if (typeof _loop !== 'boolean') {\n        return this._loop;\n      }\n\n      this._loop = _loop;\n      this._setLoop(_loop);\n\n      return this;\n    }\n\n    /**\n     * Destroys the dependencies and release the memory.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      // If the sound is already destroyed return.\n      if (this._state === SoundState.Destroyed) {\n        return this;\n      }\n\n      // Stop the sound.\n      this.stop();\n\n      this._gainNode.disconnect();\n\n      this._buffer = null;\n      this._context = null;\n      this._gainNode = null;\n\n      // Set the state to \"destroyed\".\n      this._state = SoundState.Destroyed;\n\n      this._destroyCallback && this._destroyCallback(this);\n\n      return this;\n    }\n\n    /**\n     * Returns the unique id of the sound.\n     * @return {number}\n     */\n\n  }, {\n    key: 'id',\n    value: function id() {\n      return this._id;\n    }\n\n    /**\n     * Returns whether the sound is muted or not.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'muted',\n    value: function muted() {\n      return this._muted;\n    }\n\n    /**\n     * Returns the state of the sound.\n     * @return {SoundState}\n     */\n\n  }, {\n    key: 'state',\n    value: function state() {\n      return this._state;\n    }\n\n    /**\n     * Returns the total duration of the playback.\n     * @return {number}\n     */\n\n  }, {\n    key: 'duration',\n    value: function duration() {\n      return this._duration;\n    }\n\n    /**\n     * Returns true if the buzz is playing.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isPlaying',\n    value: function isPlaying() {\n      return this._state === SoundState.Playing;\n    }\n\n    /**\n     * Returns true if buzz is paused.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isPaused',\n    value: function isPaused() {\n      return this._state === SoundState.Paused;\n    }\n\n    /**\n     * Returns the gain node.\n     * @return {GainNode}\n     */\n\n  }, {\n    key: '_gain',\n    value: function _gain() {\n      return this._gainNode;\n    }\n\n    /**\n     * Stops the playing buffer source node and destroys it.\n     * @private\n     */\n\n  }, {\n    key: '_destroyBufferNode',\n    value: function _destroyBufferNode() {\n      if (!this._bufferSourceNode) {\n        return;\n      }\n\n      if (typeof this._bufferSourceNode.stop !== 'undefined') {\n        this._bufferSourceNode.stop();\n      } else {\n        this._bufferSourceNode.noteGrainOff();\n      }\n\n      this._bufferSourceNode.disconnect();\n      this._bufferSourceNode.removeEventListener('ended', this._onEnded);\n      this._bufferSourceNode = null;\n    }\n\n    /**\n     * Sets the sound to play repeatedly or not.\n     * @param {boolean} loop True to play the sound repeatedly.\n     * @private\n     */\n\n  }, {\n    key: '_setLoop',\n    value: function _setLoop(loop) {\n      if (!this._bufferSourceNode) {\n        return;\n      }\n\n      this._bufferSourceNode.loop = loop;\n\n      if (loop) {\n        this._bufferSourceNode.loopStart = this._startPos;\n        this._bufferSourceNode.loopEnd = this._endPos;\n      }\n    }\n  }]);\n\n  return Sound;\n}();\n\nexports.default = Sound;\nexports.SoundState = SoundState;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Engine = __webpack_require__(2);\n\nvar _Engine2 = _interopRequireDefault(_Engine);\n\nvar _Queue = __webpack_require__(4);\n\nvar _Queue2 = _interopRequireDefault(_Queue);\n\nvar _Utility = __webpack_require__(0);\n\nvar _Utility2 = _interopRequireDefault(_Utility);\n\nvar _Emitter = __webpack_require__(1);\n\nvar _Emitter2 = _interopRequireDefault(_Emitter);\n\nvar _Loader = __webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum that represents the different states of a sound group (buzz).\n * @enum {string}\n */\nvar BuzzState = {\n  Ready: 'ready',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Enum that represents the different events fired by a buzz.\n * @enum {string}\n */\nvar BuzzEvents = {\n  Load: 'load',\n  UnLoad: 'unload',\n  PlayStart: 'playstart',\n  PlayEnd: 'playend',\n  Pause: 'pause',\n  Stop: 'stop',\n  Volume: 'volume',\n  Mute: 'mute',\n  Seek: 'seek',\n  Rate: 'rate',\n  Error: 'error',\n  Destroy: 'destroy'\n};\n\n/**\n * Enum that represents the different states occurs while loading a sound.\n * @enum {string}\n */\nvar LoadState = {\n  NotLoaded: 'notloaded',\n  Loading: 'loading',\n  Loaded: 'loaded'\n};\n\n/**\n * A wrapper class that simplifies dealing with group of sounds.\n */\n\nvar Buzz = function () {\n\n  /**\n   * Initializes the internal properties.\n   * @param {string|Array<string>|object} args The input parameters of this sound group.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {string|string[]} args.src Single or array of audio urls/base64 strings.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {boolean} [args.preload = false] True to pre-load the sound after construction.\n   * @param {boolean} [args.autoplay = false] True to play automatically after construction.\n   * @param {string|string[]} [args.format] The file format(s) of the passed audio source(s).\n   * @param {object} [args.sprite] The sprite definition.\n   * @param {function} [args.onload] Event-handler for the \"load\" event.\n   * @param {function} [args.onunload] Event-handler for the \"unload\" event.\n   * @param {function} [args.onplaystart] Event-handler for the \"playstart\" event.\n   * @param {function} [args.onplayend] Event-handler for the \"playend\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onrate] Event-handler for the \"rate\" event.\n   * @param {function} [args.onseek] Event-handler for the \"seek\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondestroy] Event-handler for the \"destroy\" event.\n   * @constructor\n   */\n\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n\n\n  /**\n   * Represents the different states that occurs while loading the sound.\n   * @type {LoadState}\n   * @protected\n   */\n\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @protected\n   */\n\n\n  /**\n   * True to auto-play the sound on construction.\n   * @type {boolean}\n   * @protected\n   */\n\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @protected\n   */\n\n\n  /**\n   * The current rate of the playback. Should be from 0.5 to 5.\n   * @type {number}\n   * @protected\n   */\n\n\n  /**\n   * The sprite definition.\n   * @type {object}\n   * @protected\n   */\n\n\n  /**\n   * Represents the source of the sound. The source can be an url or base64 string.\n   * @type {*}\n   * @protected\n   */\n  function Buzz(args) {\n    _classCallCheck(this, Buzz);\n\n    this._id = -1;\n    this._src = null;\n    this._format = [];\n    this._sprite = null;\n    this._volume = 1.0;\n    this._rate = 1;\n    this._muted = false;\n    this._loop = false;\n    this._preload = false;\n    this._autoplay = false;\n    this._buffer = null;\n    this._duration = 0;\n    this._compatibleSrc = null;\n    this._loadState = LoadState.NotLoaded;\n    this._state = BuzzState.Ready;\n    this._queue = null;\n    this._engine = null;\n\n    // Setup the audio engine.\n    this._engine = _Engine2.default;\n    this._engine.setup();\n\n    // If no audio is available throw error.\n    if (!this._engine.isAudioAvailable()) {\n      this._fire(BuzzEvents.Error, null, { type: _Engine.ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    if (typeof args === 'string') {\n      this._src = [args];\n    } else if (Array.isArray(args) && args.length) {\n      this._src = args;\n    } else if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object') {\n      var id = args.id,\n          src = args.src,\n          format = args.format,\n          sprite = args.sprite,\n          volume = args.volume,\n          rate = args.rate,\n          muted = args.muted,\n          loop = args.loop,\n          autoplay = args.autoplay,\n          preload = args.preload,\n          onload = args.onload,\n          onunload = args.onunload,\n          onplaystart = args.onplaystart,\n          onplayend = args.onplayend,\n          onstop = args.onstop,\n          onpause = args.onpause,\n          onmute = args.onmute,\n          onvolume = args.onvolume,\n          onrate = args.onrate,\n          onseek = args.onseek,\n          onerror = args.onerror,\n          ondestroy = args.ondestroy;\n\n      // Set the passed id or the random one.\n\n      this._id = typeof id === 'number' ? id : _Utility2.default.id();\n\n      // Set the source.\n      if (typeof src === 'string') {\n        this._src = [src];\n      } else if (Array.isArray(src) && src.length) {\n        this._src = src;\n      }\n\n      // Set the format.\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      // Set other properties.\n      (typeof sprite === 'undefined' ? 'undefined' : _typeof(sprite)) === 'object' && (this._sprite = sprite);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (this._rate = rate);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof loop === 'boolean' && (this._loop = loop);\n      typeof autoplay === 'boolean' && (this._autoplay = autoplay);\n      typeof preload === 'boolean' && (this._preload = preload);\n      typeof onload === 'function' && this.on(BuzzEvents.Load, onload);\n      typeof onunload === 'function' && this.on(BuzzEvents.UnLoad, onunload);\n\n      // Bind the passed event handlers to events.\n      typeof onplaystart === 'function' && this.on(BuzzEvents.PlayStart, onplaystart);\n      typeof onplayend === 'function' && this.on(BuzzEvents.PlayEnd, onplayend);\n      typeof onstop === 'function' && this.on(BuzzEvents.Stop, onstop);\n      typeof onpause === 'function' && this.on(BuzzEvents.Pause, onpause);\n      typeof onmute === 'function' && this.on(BuzzEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(BuzzEvents.Volume, onvolume);\n      typeof onrate === 'function' && this.on(BuzzEvents.Rate, onrate);\n      typeof onseek === 'function' && this.on(BuzzEvents.Seek, onseek);\n      typeof onerror === 'function' && this.on(BuzzEvents.Error, onerror);\n      typeof ondestroy === 'function' && this.on(BuzzEvents.Destroy, ondestroy);\n    }\n\n    // Throw error if source is not passed.\n    if (!this._src) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    // Instantiate the dependencies.\n    this._queue = new _Queue2.default();\n\n    if (this._autoplay) {\n      this.play();\n    } else if (this._preload) {\n      this.load();\n    }\n  }\n\n  /**\n   * Loads the sound to the underlying audio object.\n   * @return {Buzz}\n   */\n\n\n  /**\n   * The audio engine.\n   * @type {Engine}\n   * @private\n   */\n\n\n  /**\n   * Represents the state of this group.\n   * @type {BuzzState}\n   * @private\n   */\n\n\n  /**\n   * The best compatible source in the audio sources passed.\n   * @type {string|null}\n   * @protected\n   */\n\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n\n\n  /**\n   * True to pre-loaded the sound on construction.\n   * @type {boolean}\n   * @protected\n   */\n\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @protected\n   */\n\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @protected\n   */\n\n\n  /**\n   * The formats of the passed audio sources.\n   * @type {Array<string>}\n   * @protected\n   */\n\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @protected\n   */\n\n\n  _createClass(Buzz, [{\n    key: 'load',\n    value: function load() {\n      var _this = this;\n\n      // If the sound is already loaded return without reloading again.\n      if (this.isLoaded() || this._loadState === LoadState.Loading) {\n        return this;\n      }\n\n      // Set the state to \"Loading\" to avoid loading multiple times.\n      this._loadState = LoadState.Loading;\n\n      // Get the compatible source.\n      var src = this._compatibleSrc || (this._compatibleSrc = this.getCompatibleSource());\n\n      // If no compatible source found call failure method and return.\n      if (!src) {\n        this._onLoadFailure('The audio formats you passed are not supported');\n        return this;\n      }\n\n      // Load the audio source.\n      this._engine.load(src).then(function (downloadResult) {\n        // During the time of loading... if the buzz is unloaded or destroyed then return.\n        if (_this._loadState === LoadState.NotLoaded || _this._state === BuzzState.Destroyed) {\n          return;\n        }\n\n        // If loading succeeded,\n        // i. Save the result.\n        // ii. Set the load state as loaded.\n        // iii. Fire the load event.\n        // iv. Run the methods that are queued to run after successful load.\n        if (downloadResult.status === _Loader.DownloadStatus.Success) {\n          _this._buffer = downloadResult.value;\n          _this._duration = _this._buffer.duration;\n          _this._loadState = LoadState.Loaded;\n          _this._fire(BuzzEvents.Load, null, downloadResult);\n          _this._queue.run('after-load');\n          return;\n        }\n\n        _this._onLoadFailure(downloadResult.error);\n      });\n\n      return this;\n    }\n\n    /**\n     * Called on failure of loading audio source.\n     * @param {*} error The audio source load error.\n     * @protected\n     */\n\n  }, {\n    key: '_onLoadFailure',\n    value: function _onLoadFailure(error) {\n      // Remove the queued actions from this class that are supposed to run after load.\n      this._queue.remove('after-load');\n\n      // Set the load state back to not loaded.\n      this._loadState = LoadState.NotLoaded;\n\n      // Fire the error event.\n      this._fire(BuzzEvents.Error, null, { type: _Engine.ErrorType.LoadError, error: error });\n    }\n\n    /**\n     * Returns the first compatible source based on the passed sources and the format.\n     * @return {string}\n     */\n\n  }, {\n    key: 'getCompatibleSource',\n    value: function getCompatibleSource() {\n      // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n      return this._format.length ? this._src[this._format.indexOf(_Utility2.default.getSupportedFormat(this._format))] : _Utility2.default.getSupportedSource(this._src);\n    }\n\n    /**\n     * Plays the passed sound defined in the sprite or the sound that belongs to the passed id.\n     * @param {string|number} [soundOrId] The sound name defined in sprite or the sound id.\n     * @return {Buzz|number}\n     */\n\n  }, {\n    key: 'play',\n    value: function play(soundOrId) {\n      var _this2 = this;\n\n      var isIdPassed = typeof soundOrId === 'number';\n\n      // If id is passed then get the sound from the engine and play it.\n      if (isIdPassed) {\n        var sound = this._engine.sound(soundOrId);\n\n        if (sound) {\n          sound.play();\n          this._fire(BuzzEvents.PlayStart, soundOrId);\n        }\n\n        return this;\n      }\n\n      var newSoundId = _Utility2.default.id(),\n          playSound = function playSound() {\n        var soundArgs = {\n          id: newSoundId,\n          buffer: _this2._buffer,\n          volume: _this2._volume,\n          rate: _this2._rate,\n          muted: _this2._muted,\n          loop: _this2._loop,\n          playEndCallback: function playEndCallback(sound) {\n            return _this2._fire(BuzzEvents.PlayEnd, sound.id());\n          },\n          destroyCallback: function destroyCallback(sound) {\n            _this2._fire(BuzzEvents.Destroy, sound.id());\n            _Emitter2.default.clear(sound.id());\n          }\n        };\n\n        if (typeof soundOrId === 'string' && _this2._sprite && _this2._sprite.hasOwnProperty(soundOrId)) {\n          var positions = _this2._sprite[soundOrId];\n          soundArgs.startPos = positions[0];\n          soundArgs.endPos = positions[1];\n        }\n\n        var newSound = _this2._engine.sound(_this2._compatibleSrc, _this2._id, soundArgs);\n        newSound.play();\n\n        _this2._fire(BuzzEvents.PlayStart, newSound.id());\n      };\n\n      // If the sound is not yet loaded push an action to the queue to play the sound once it's loaded.\n      if (!this.isLoaded()) {\n        this._queue.add('after-load', 'play-' + newSoundId, function () {\n          return playSound();\n        });\n        this.load();\n      } else {\n        playSound();\n      }\n\n      return newSoundId;\n    }\n\n    /**\n     * Pauses the sound belongs to the passed id or all the sounds belongs to this group.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause(id) {\n      this._queue.remove('after-load', id ? 'play-' + id : null);\n      this._sounds(id).forEach(function (sound) {\n        return sound.pause();\n      });\n      this._fire(BuzzEvents.Pause, id);\n\n      return this;\n    }\n\n    /**\n     * Stops the sound belongs to the passed id or all the sounds belongs to this group.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(id) {\n      this._queue.remove('after-load', id ? 'play-' + id : null);\n      this._sounds(id).forEach(function (sound) {\n        return sound.stop();\n      });\n      this._fire(BuzzEvents.Stop, id);\n\n      return this;\n    }\n\n    /**\n     * Mutes the sound belongs to the passed id or all the sounds belongs to this group.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute(id) {\n      this._sounds(id).forEach(function (sound) {\n        return sound.mute();\n      });\n      typeof id !== 'number' && (this._muted = true);\n      this._fire(BuzzEvents.Mute, id, this._muted);\n\n      return this;\n    }\n\n    /**\n     * Un-mutes the sound belongs to the passed id or all the sounds belongs to this group.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute(id) {\n      this._sounds(id).forEach(function (sound) {\n        return sound.unmute();\n      });\n      typeof id !== 'number' && (this._muted = false);\n      this._fire(BuzzEvents.Mute, id, this._muted);\n\n      return this;\n    }\n\n    /**\n     * Gets/sets the volume of the passed sound or the group.\n     * @param {number} [volume] Should be from 0.0 to 1.0.\n     * @param {number} [id] The sound id.\n     * @return {Buzz|number}\n     */\n\n  }, {\n    key: 'volume',\n    value: function volume(_volume, id) {\n      if (typeof _volume === 'number' && _volume >= 0 && _volume <= 1.0) {\n        this._sounds(id).forEach(function (sound) {\n          return sound.volume(_volume);\n        });\n        typeof id !== 'number' && (this._volume = _volume);\n        this._fire(BuzzEvents.Volume, id, this._volume);\n        return this;\n      }\n\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.volume() : null;\n      }\n\n      return this._volume;\n    }\n\n    /**\n     * Gets/sets the rate of the passed sound or the group.\n     * @param {number} [rate] Should be from 0.5 to 5.0.\n     * @param {number} [id] The sound id.\n     * @return {Buzz|number}\n     */\n\n  }, {\n    key: 'rate',\n    value: function rate(_rate, id) {\n      if (typeof _rate === 'number' && _rate >= 0.5 && _rate <= 5) {\n        this._sounds(id).forEach(function (sound) {\n          return sound.rate(_rate);\n        });\n        typeof id !== 'number' && (this._rate = _rate);\n        this._fire(BuzzEvents.Rate, id, this._rate);\n        return this;\n      }\n\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.rate() : null;\n      }\n\n      return this._rate;\n    }\n\n    /**\n     * Gets/sets the current playback position of the sound.\n     * @param {number} id The sound id\n     * @param {number} [seek] The seek position.\n     * @return {Buzz|number}\n     */\n\n  }, {\n    key: 'seek',\n    value: function seek(id, _seek) {\n      var _this3 = this;\n\n      var sound = this._engine.sound(id);\n\n      if (!sound) {\n        return this;\n      }\n\n      if (typeof _seek === 'number') {\n        // If the audio source is not yet loaded push an item to the queue to seek after the sound is loaded\n        // and load the sound.\n        if (!this.isLoaded()) {\n          this._queue.add('after-load', 'seek-' + id, function () {\n            return _this3.seek(id, _seek);\n          });\n          this.load();\n          return this;\n        }\n\n        sound.seek(_seek);\n        this._fire(BuzzEvents.Seek, id, _seek);\n        return this;\n      }\n\n      return sound.seek();\n    }\n\n    /**\n     * Gets/sets the looping behavior of a sound or the group.\n     * @param {boolean} [loop] True to loop the sound.\n     * @param {number} [id] The sound id.\n     * @return {Buzz|boolean}\n     */\n\n  }, {\n    key: 'loop',\n    value: function loop(_loop, id) {\n      if (typeof _loop === 'boolean') {\n        this._sounds(id).forEach(function (sound) {\n          return sound.loop(_loop);\n        });\n        typeof id !== 'number' && (this._loop = _loop);\n        return this;\n      }\n\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.loop() : null;\n      }\n\n      return this._loop;\n    }\n\n    /**\n     * Returns true if the passed sound is playing.\n     * @param {number} id The sound id.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'playing',\n    value: function playing(id) {\n      var sound = this._engine.sound(id);\n      return sound ? sound.isPlaying() : null;\n    }\n\n    /**\n     * Returns true if the passed sound is muted or the group is muted.\n     * @param {number} [id] The sound id.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'muted',\n    value: function muted(id) {\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.muted() : null;\n      }\n\n      return this._muted;\n    }\n\n    /**\n     * Returns the state of the passed sound or the group.\n     * @return {BuzzState|SoundState}\n     */\n\n  }, {\n    key: 'state',\n    value: function state(id) {\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.state() : null;\n      }\n\n      return this._state;\n    }\n\n    /**\n     * Returns the duration of the passed sound or the total duration of the sound.\n     * @param {number} [id] The sound id.\n     * @return {number}\n     */\n\n  }, {\n    key: 'duration',\n    value: function duration(id) {\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? sound.duration() : null;\n      }\n\n      return this._duration;\n    }\n\n    /**\n     * Unloads the loaded audio buffer.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'unload',\n    value: function unload() {\n      this._queue.remove('after-load');\n      this._engine.unload(this._compatibleSrc);\n      this._buffer = null;\n      this._duration = 0;\n      this._loadState = LoadState.NotLoaded;\n      return this;\n    }\n\n    /**\n     * Stops and destroys all the sounds belong to this group and release other dependencies.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._state === BuzzState.Destroyed) {\n        return this;\n      }\n\n      this.stop();\n      this._queue.clear();\n      this._engine.free(false, this._id);\n\n      this._buffer = null;\n      this._queue = null;\n      this._engine = null;\n      this._state = BuzzState.Destroyed;\n\n      this._fire(BuzzEvents.Destroy);\n\n      _Emitter2.default.clear(this._id);\n    }\n\n    /**\n     * Subscribes to an event for the sound or the group.\n     * @param {string} eventName The event name.\n     * @param {function} handler The event handler.\n     * @param {boolean} [once = false] True for one-time event handling.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(eventName, handler) {\n      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var id = arguments[3];\n\n      _Emitter2.default.on(id || this._id, eventName, handler, once);\n      return this;\n    }\n\n    /**\n     * Un-subscribes from an event for the sound or the group.\n     * @param {string} eventName The event name.\n     * @param {function} handler The event handler.\n     * @param {number} [id] The sound id.\n     * @return {Buzz}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(eventName, handler, id) {\n      _Emitter2.default.off(id || this._id, eventName, handler);\n      return this;\n    }\n\n    /**\n     * Returns the unique id of the sound.\n     * @return {number}\n     */\n\n  }, {\n    key: 'id',\n    value: function id() {\n      return this._id;\n    }\n\n    /**\n     * Returns the audio resource loading status.\n     * @return {LoadState}\n     */\n\n  }, {\n    key: 'loadState',\n    value: function loadState() {\n      return this._loadState;\n    }\n\n    /**\n     * Returns true if the audio source is loaded.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isLoaded',\n    value: function isLoaded() {\n      return this._loadState === LoadState.Loaded;\n    }\n\n    /**\n     * Returns the sound for the passed id.\n     * @param {number} id The sound id.\n     * @return {Sound}\n     */\n\n  }, {\n    key: 'sound',\n    value: function sound(id) {\n      return this._engine.sound(id);\n    }\n\n    /**\n     * Returns true if the passed sound exists.\n     * @param {number} id The sound id.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'alive',\n    value: function alive(id) {\n      return Boolean(this.sound(id));\n    }\n\n    /**\n     * Returns the sound for the passed id or all the sounds belong to this group.\n     * @param {number} [id] The sound id.\n     * @return {Array<Sound>}\n     * @private\n     */\n\n  }, {\n    key: '_sounds',\n    value: function _sounds(id) {\n      if (typeof id === 'number') {\n        var sound = this._engine.sound(id);\n        return sound ? [sound] : [];\n      }\n\n      return this._engine.sounds(this._id);\n    }\n\n    /**\n     * Fires an event of group or sound.\n     * @param {string} eventName The event name.\n     * @param {number} [id] The sound id.\n     * @param {...*} args The arguments that to be passed to handler.\n     * @return {Buzz}\n     * @private\n     */\n\n  }, {\n    key: '_fire',\n    value: function _fire(eventName, id) {\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      if (id) {\n        _Emitter2.default.fire.apply(_Emitter2.default, [id, eventName].concat(args, [this.sound(id), this]));\n      } else {\n        _Emitter2.default.fire.apply(_Emitter2.default, [this._id, eventName].concat(args, [this]));\n      }\n\n      return this;\n    }\n  }]);\n\n  return Buzz;\n}();\n\nvar $buzz = function $buzz(args) {\n  return new Buzz(args);\n};\n['setup', 'load', 'unload', 'mute', 'unmute', 'volume', 'stop', 'suspend', 'resume', 'terminate', 'muted', 'state', 'context', 'isAudioAvailable', 'on', 'off'].forEach(function (method) {\n  $buzz[method] = function () {\n    var result = _Engine2.default[method].apply(_Engine2.default, arguments);\n    return result === _Engine2.default ? $buzz : result;\n  };\n});\n\nmodule.exports = $buzz;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// musquito-1.0.2.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fb0840691fc92f5cb921","/**\n * Contains helper methods.\n */\nclass Utility {\n\n  /**\n   * The navigator object.\n   * @type {Navigator}\n   * @private\n   */\n  _navigator = null;\n\n  /**\n   * The AudioContext type.\n   * @type {Function}\n   * @private\n   */\n  _contextType = null;\n\n  /**\n   * Dictionary of audio formats and their support status.\n   * @type {object}\n   * @private\n   */\n  _formats = {};\n\n  /**\n   * Is audio already enabled or not.\n   * @type {boolean}\n   * @private\n   */\n  _isAudioEnabled = false;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    if (typeof navigator !== 'undefined') {\n      this._navigator = navigator;\n    }\n\n    // Set the available Web Audio Context type available in browser.\n    if (typeof AudioContext !== 'undefined') {\n      this._contextType = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n      this._contextType = webkitAudioContext;\n    }\n\n    // Determine the supported audio formats.\n    let audio = new Audio();\n\n    this._formats = {\n      mp3: Boolean(audio.canPlayType('audio/mp3;').replace(/^no$/, '')),\n      mpeg: Boolean(audio.canPlayType('audio/mpeg;').replace(/^no$/, '')),\n      opus: Boolean(audio.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')),\n      ogg: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      oga: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      wav: Boolean(audio.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n      aac: Boolean(audio.canPlayType('audio/aac;').replace(/^no$/, '')),\n      caf: Boolean(audio.canPlayType('audio/x-caf;').replace(/^no$/, '')),\n      m4a: Boolean((audio.canPlayType('audio/x-m4a;') ||\n      audio.canPlayType('audio/m4a;') ||\n      audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      mp4: Boolean((audio.canPlayType('audio/x-mp4;') ||\n      audio.canPlayType('audio/mp4;') ||\n      audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      weba: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      webm: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      dolby: Boolean(audio.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, '')),\n      flac: Boolean((audio.canPlayType('audio/x-flac;') || audio.canPlayType('audio/flac;')).replace(/^no$/, ''))\n    };\n\n    audio = null;\n  }\n\n  /**\n   * Returns an unique id (credit: https://howlerjs.com).\n   * @return {number}\n   */\n  id() {\n    return Math.round(Date.now() * Math.random());\n  }\n\n  /**\n   * Returns the available context type.\n   * @return {Function}\n   */\n  getContextType() {\n    return this._contextType;\n  }\n\n  /**\n   * Instantiates and returns the audio context.\n   * @return {AudioContext|webkitAudioContext}\n   */\n  getContext() {\n    return new this._contextType();\n  }\n\n  /**\n   * Returns the supported audio formats.\n   * @return {Object}\n   */\n  supportedFormats() {\n    return this._formats;\n  }\n\n  /**\n   * Returns true if the passed format is supported.\n   * @param {string} format The audio format ex. \"mp3\"\n   * @return {boolean}\n   */\n  isFormatSupported(format) {\n    return Boolean(this._formats[format]);\n  }\n\n  /**\n   * Returns the first supported format from the passed array.\n   * @param {string[]} formats Array of audio formats\n   * @return {string}\n   */\n  getSupportedFormat(formats) {\n    return formats.find(format => this.isFormatSupported(format));\n  }\n\n  /**\n   * Returns true if the audio source is supported.\n   * @param {string} source The audio source url or base64 string\n   * @return {boolean}\n   */\n  isSourceSupported(source) {\n    let ext = this.isBase64(source) ?\n      (/^data:audio\\/([^;,]+);/i).exec(source) :\n      (/^.+\\.([^.]+)$/).exec(source);\n\n    ext = (/^.+\\.([^.]+)$/).exec(source);\n    return ext ? this.isFormatSupported(ext[1].toLowerCase()) : false;\n  }\n\n  /**\n   * Returns the first supported audio source from the passed array.\n   * @param {string[]} sources Array of audio sources. The audio source could be either url or base64 string.\n   * @return {string}\n   */\n  getSupportedSource(sources) {\n    return sources.find(source => this.isSourceSupported(source));\n  }\n\n  /**\n   * Returns whether the passed string is a base64 string or not.\n   * @param {string} str Base64 audio string\n   * @return {boolean}\n   */\n  isBase64(str) {\n    return (/^data:[^;]+;base64,/).test(str);\n  }\n\n  /**\n   * Enables playing audio on first touch.\n   * @param {AudioContext} context Web API audio context.\n   */\n  enableAudio(context) {\n    if (!this._isMobile() && !this._isTouch() || this._isAudioEnabled) {\n      return;\n    }\n\n    const unlock = () => {\n      let bufferSource = context.createBufferSource();\n      bufferSource.buffer = context.createBuffer(1, 1, 22050);\n      bufferSource.connect(context.destination);\n\n      const cleanUp = () => {\n        document.removeEventListener('touchend', unlock);\n        bufferSource.disconnect();\n        bufferSource.removeEventListener('ended', cleanUp);\n        bufferSource = null;\n      };\n\n      bufferSource.addEventListener('ended', cleanUp);\n\n      if (typeof bufferSource.start === 'undefined') {\n        bufferSource.noteOn(0);\n      } else {\n        bufferSource.start(0);\n      }\n    };\n\n    document.addEventListener('touchend', unlock);\n  }\n\n  /**\n   * Returns true if the platform is mobile.\n   * @return {boolean}\n   * @private\n   */\n  _isMobile() {\n    if (!this._navigator) {\n      return false;\n    }\n\n    return (/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i).test(this._navigator.userAgent);\n  }\n\n  /**\n   * Returns true if the platform is touch supported.\n   * @return {boolean}\n   * @private\n   */\n  _isTouch() {\n    return typeof window !== 'undefined' && (Boolean(('ontouchend' in window) ||\n        (this._navigator && this._navigator.maxTouchPoints > 0) ||\n        (this._navigator && this._navigator.msMaxTouchPoints > 0)));\n  }\n}\n\nexport default new Utility();\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/Utility.js","/**\n * Singleton global event emitter.\n * @class\n */\nclass Emitter {\n\n  /**\n   * Dictionary that maps the objects with their events and handlers.\n   * @type {object}\n   * @private\n   */\n  _objectsEventsHandlersMap = {};\n\n  /**\n   * Subscribes to an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName Name of the event\n   * @param {function} handler The event-handler function\n   * @param {boolean} [once = false] Is it one-time subscription or not?\n   * @return {Emitter}\n   */\n  on(id, eventName, handler, once = false) {\n    if (!this._hasObject(id)) {\n      this._objectsEventsHandlersMap[id] = {};\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!objEvents.hasOwnProperty(eventName)) {\n      objEvents[eventName] = [];\n    }\n\n    objEvents[eventName].push({\n      handler: handler,\n      once: once\n    });\n\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Emitter}\n   */\n  off(id, eventName, handler) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!handler) {\n      objEvents[eventName] = [];\n    } else {\n      objEvents[eventName] = objEvents[eventName].filter(eventSubscriber => {\n        return eventSubscriber.handler !== handler;\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Fires an event of the object passing the source and other optional arguments.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name\n   * @param {...*} args The arguments that to be passed to handler\n   * @return {Emitter}\n   */\n  fire(id, eventName, ...args) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    let eventSubscribers = this._objectsEventsHandlersMap[id][eventName];\n\n    for (let i = 0; i < eventSubscribers.length; i++) {\n      let eventSubscriber = eventSubscribers[i];\n\n      setTimeout(function (subscriber) {\n        const { handler, once } = subscriber;\n\n        handler(...args);\n\n        if (once) {\n          this.off(id, eventName, handler);\n        }\n      }.bind(this, eventSubscriber), 0);\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the event handlers of the passed object.\n   * @param {number} [id] The unique id of the object.\n   * @return {Emitter}\n   */\n  clear(id) {\n    if (!id) {\n      this._objectsEventsHandlersMap = {};\n      return this;\n    }\n\n    if (this._hasObject(id)) {\n      delete this._objectsEventsHandlersMap[id];\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns true if the object is already registered.\n   * @param {number} id The object id.\n   * @return {boolean}\n   * @private\n   */\n  _hasObject(id) {\n    return this._objectsEventsHandlersMap.hasOwnProperty(id);\n  }\n\n  /**\n   * Returns true if the passed object has an entry of the passed event.\n   * @param {number} id The object id.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   * @private\n   */\n  _hasEvent(id, eventName) {\n    return this._hasObject(id) && this._objectsEventsHandlersMap[id].hasOwnProperty(eventName);\n  }\n}\n\nexport default new Emitter();\n\n\n\n// WEBPACK FOOTER //\n// ./src/Emitter.js","import Loader from './Loader';\nimport emitter from './Emitter';\nimport Heap from './Heap';\nimport Queue from './Queue';\nimport utility from './Utility';\nimport Sound from './Sound';\n\n/**\n * Enum that represents the different type of errors thrown by Engine and Buzzes.\n * @enum {string}\n */\nconst ErrorType = {\n  NoAudio: 'no-audio',\n  LoadError: 'load',\n  PlayError: 'play',\n  EngineError: 'engine'\n};\n\n/**\n * Represents the different states of the audio engine.\n * @enum {string}\n */\nconst EngineState = {\n  NotReady: 'notready',\n  Ready: 'ready',\n  Suspending: 'suspending',\n  Suspended: 'suspended',\n  Resuming: 'resuming',\n  Destroying: 'destroying',\n  Done: 'done',\n  NoAudio: 'no-audio'\n};\n\n/**\n * Enum that represents the different events by engine.\n * @enum {string}\n */\nconst EngineEvents = {\n  Add: 'add',\n  Remove: 'remove',\n  Volume: 'volume',\n  Mute: 'mute',\n  Pause: 'pause',\n  Stop: 'stop',\n  Suspend: 'suspend',\n  Resume: 'resume',\n  Error: 'error',\n  Done: 'done'\n};\n\n/**\n * The audio engine that orchestrates all the sounds.\n * @class\n */\nclass Engine {\n\n  /**\n   * Unique id of the engine.\n   * @type {number}\n   * @private\n   */\n  _id = utility.id();\n\n  /**\n   * Represents whether the audio engine is currently muted or not.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * Represents the global volume.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The heap clean-up period.\n   * @type {number}\n   * @private\n   */\n  _cleanUpInterval = 5;\n\n  /**\n   * The clean-up interval id.\n   * @type {number|null}\n   * @private\n   */\n  _intervalId = null;\n\n  /**\n   * True if Web Audio API is available.\n   * @type {boolean}\n   * @private\n   */\n  _isAudioAvailable = false;\n\n  /**\n   * Represents the current state of the engine.\n   * @type {EngineState}\n   * @private\n   */\n  _state = EngineState.NotReady;\n\n  /**\n   * The Web Audio API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The master gain node.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The sound heap.\n   * @type {Heap}\n   * @private\n   */\n  _heap = null;\n\n  /**\n   * Loader - the component that loads audio buffers with audio data.\n   * @type {Loader}\n   * @private\n   */\n  _loader = null;\n\n  /**\n   * Instantiates the heap and action queue.\n   * @constructor\n   */\n  constructor() {\n    this._heap = new Heap();\n    this._queue = new Queue();\n  }\n\n  /**\n   * Instantiate the audio context and other dependencies.\n   * @param {object} [args] Input parameters object.\n   * @param {number} [args.volume = 1.0] The global volume of the sound engine.\n   * @param {boolean} [args.muted = false] Stay muted initially or not.\n   * @param {number} [args.cleanUpInterval = 5] The heap clean-up interval period in minutes.\n   * @param {function} [args.onadd] Event-handler for the \"add\" event.\n   * @param {function} [args.onremove] Event-handler for the \"remove\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onsuspend] Event-handler for the \"suspend\" event.\n   * @param {function} [args.onresume] Event-handler for the \"resume\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondone] Event-handler for the \"done\" event.\n   * @return {Engine}\n   */\n  setup(args) {\n    // If the setup is already done return.\n    if (this._state !== EngineState.NotReady) {\n      return this;\n    }\n\n    this._context = utility.getContext();\n\n    // Determine the audio stuff available in the current platform and set the flags accordingly.\n    this._isAudioAvailable = Boolean(this._context);\n\n    // If no Web Audio and HTML5 audio is available fire an error event.\n    if (!this._isAudioAvailable) {\n      this._state = EngineState.NoAudio;\n      this._fire(EngineEvents.Error, { type: ErrorType.NoAudio, error: 'Web Audio API is not available' });\n      return this;\n    }\n\n    // Read the input parameters from the options.\n    const {\n      volume,\n      muted,\n      cleanUpInterval,\n      onadd,\n      onremove,\n      onstop,\n      onpause,\n      onmute,\n      onvolume,\n      onsuspend,\n      onresume,\n      onerror,\n      ondone\n    } = args || {};\n\n    // Set the properties from the read parameters.\n    typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n    typeof muted === 'boolean' && (this._muted = muted);\n    typeof cleanUpInterval === 'number' && (this._cleanUpInterval = cleanUpInterval);\n    typeof onadd === 'function' && this.on(EngineEvents.Add, onadd);\n    typeof onremove === 'function' && this.on(EngineEvents.Remove, onremove);\n    typeof onstop === 'function' && this.on(EngineEvents.Stop, onstop);\n    typeof onpause === 'function' && this.on(EngineEvents.Pause, onpause);\n    typeof onmute === 'function' && this.on(EngineEvents.Mute, onmute);\n    typeof onvolume === 'function' && this.on(EngineEvents.Volume, onvolume);\n    typeof onsuspend === 'function' && this.on(EngineEvents.Suspend, onsuspend);\n    typeof onresume === 'function' && this.on(EngineEvents.Resume, onresume);\n    typeof onerror === 'function' && this.on(EngineEvents.Error, onerror);\n    typeof ondone === 'function' && this.on(EngineEvents.Done, ondone);\n\n    // Create the buffer loader.\n    this._loader = new Loader(this._context);\n\n    // Auto-enable audio for the mobile devices in the first touch.\n    utility.enableAudio(this._context);\n\n    // Create the audio graph.\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n    this._gainNode.connect(this._context.destination);\n\n    this._intervalId = window.setInterval(this._heap.free, this._cleanUpInterval * 60 * 1000);\n\n    this._state = EngineState.Ready;\n\n    return this;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers and returns them.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @return {Promise}\n   */\n  load(urls) {\n    return this._loader.load(urls);\n  }\n\n  /**\n   * Unloads single or multiple loaded audio buffers from cache.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unload(urls) {\n    this._loader.unload(urls);\n    return this;\n  }\n\n  /**\n   * Mutes the engine.\n   * @return {Engine}\n   */\n  mute() {\n    // If the engine is already muted return.\n    if (this._muted) {\n      return this;\n    }\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the engine.\n   * @return {Engine}\n   */\n  unmute() {\n    // If the engine is not muted return.\n    if (!this._muted) {\n      return this;\n    }\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume for the audio engine that controls global volume for all sounds.\n   * @param {number} [vol] Should be within 0.0 to 1.0.\n   * @return {Engine|number}\n   */\n  volume(vol) {\n    // If no parameter is passed then return the current volume.\n    if (vol === undefined) {\n      return this._volume;\n    }\n\n    // If passed volume is not an acceptable value return.\n    if (typeof vol !== 'number' || vol < 0 || vol > 1.0) {\n      return this;\n    }\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    // Fire the \"volume\" event.\n    this._fire(EngineEvents.Volume, this._volume);\n\n    return this;\n  }\n\n  /**\n   * Stops all the currently playing sounds.\n   * @return {Engine}\n   */\n  stop() {\n    // Stop all the sounds.\n    this._heap.sounds().forEach(sound => sound.stop());\n\n    // Fire the \"stop\" event.\n    this._fire(EngineEvents.Stop);\n\n    return this;\n  }\n\n  /**\n   * Stops all the playing sounds and suspends the audio context immediately.\n   * @return {Engine}\n   */\n  suspend() {\n    // If the context is resuming then suspend after resumed.\n    if (this._state === EngineState.Resuming) {\n      this._queue.add('after-resume', 'suspend', () => this.suspend());\n      return this;\n    }\n\n    // If the state is not ready return.\n    if (this._state !== EngineState.Ready) {\n      return this;\n    }\n\n    // Stop all the playing sounds.\n    this.stop();\n\n    // Set the state to suspending.\n    this._state = EngineState.Suspending;\n\n    // Suspend the Audio Context.\n    this._context.suspend().then(() => {\n      this._state = EngineState.Suspended;\n      this._queue.run('after-suspend');\n      this._fire(EngineEvents.Suspend);\n    });\n\n    return this;\n  }\n\n  /**\n   * Resumes the audio context from the suspended mode.\n   * @return {Engine}\n   */\n  resume() {\n    // If the context is suspending then resume after suspended.\n    if (this._state === EngineState.Suspending) {\n      this._queue.add('after-suspend', 'resume', () => this.resume());\n      return this;\n    }\n\n    if (!this._state !== EngineState.Suspended) {\n      return this;\n    }\n\n    this._state = EngineState.Resuming;\n\n    this._context.resume().then(() => {\n      this._state = EngineState.Ready;\n      this._queue.run('after-resume');\n      this._fire(EngineEvents.Resume);\n    });\n\n    return this;\n  }\n\n  /**\n   * Shuts down the engine.\n   * @return {Engine}\n   */\n  terminate() {\n    if (this._state === EngineState.Done || this._state === EngineState.Destroying) {\n      return this;\n    }\n\n    const cleanUp = () => {\n      // Stop the timer.\n      this._intervalId && window.clearInterval(this._intervalId);\n      this._intervalId = null;\n\n      // Destroy the heap.\n      this._heap.destroy();\n      this._heap = null;\n\n      // Clear the cache and remove the loader.\n      if (this._loader) {\n        this._loader.dispose();\n        this._loader = null;\n      }\n\n      this._context = null;\n      this._queue.clear();\n      this._queue = null;\n      this._state = EngineState.Done;\n\n      // Fire the \"done\" event.\n      this._fire(EngineEvents.Done);\n\n      emitter.clear(this._id);\n    };\n\n    // Close the context.\n    if (this._context) {\n      if (this._state === EngineState.Suspending) {\n        this._queue.remove('after-suspend');\n        this._queue.add('after-suspend', 'destroy', () => this.terminate());\n        return this;\n      } else if (this._state === EngineState.Resuming) {\n        this._queue.remove('after-resume');\n        this._queue.add('after-resume', 'destroy', () => this.terminate());\n        return this;\n      }\n\n      this._state = EngineState.Destroying;\n      this._context && this._context.close().then(() => cleanUp());\n    } else {\n      this._state = EngineState.Destroying;\n      cleanUp();\n    }\n\n    return this;\n  }\n\n  /**\n   * Subscribes to an event.\n   * @param {string} eventName Name of the event.\n   * @param {function} handler The event-handler function.\n   * @param {boolean} [once = false] Is it one-time subscription or not.\n   * @return {Engine}\n   */\n  on(eventName, handler, once = false) {\n    emitter.on(this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Engine}\n   */\n  off(eventName, handler) {\n    emitter.off(this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the existing sound in heap or create a new one and return.\n   * @param {number|string} idOrUrl The sound id or audio url/base64 string.\n   * @param {number} [groupId] The group id.\n   * @param {object} [args] The sound creation arguments.\n   * @return {Sound}\n   */\n  sound(idOrUrl, groupId, args) {\n    if (typeof idOrUrl === 'number') {\n      return this._heap.sound(idOrUrl);\n    }\n\n    const sound = new Sound(args);\n    this._heap.add(idOrUrl, groupId, sound);\n    sound._gain().connect(this._gainNode);\n\n    return sound;\n  }\n\n  /**\n   * Returns the sounds belongs to a group or all the sounds from the heap.\n   * @param {number} [groupId] The group id.\n   * @return {Array<Sound>}\n   */\n  sounds(groupId) {\n    return this._heap.sounds(groupId);\n  }\n\n  /**\n   * Destroys the sounds belong to the passed group.\n   * @param {boolean} idle True to destroy only the idle sounds.\n   * @param {number} groupId The group id.\n   * @return {Engine}\n   */\n  free(idle, groupId) {\n    this._heap.free(idle, groupId);\n    return this;\n  }\n\n  /**\n   * Returns whether the engine is currently muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the engine.\n   * @return {EngineState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the created audio context.\n   * @return {AudioContext}\n   */\n  context() {\n    return this._context;\n  }\n\n  /**\n   * Returns true if Web Audio API is available.\n   * @return {boolean}\n   */\n  isAudioAvailable() {\n    return this._isAudioAvailable;\n  }\n\n  /**\n   * Fires an event of engine.\n   * @param {string} eventName The event name.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Engine}\n   * @private\n   */\n  _fire(eventName, ...args) {\n    emitter.fire(this._id, eventName, ...args, this);\n    return this;\n  }\n}\n\nconst engine = new Engine();\nexport { engine as default, EngineState, EngineEvents, ErrorType };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Engine.js","import utility from './Utility';\n\n/**\n * Enum to represent the download status of audio resource.\n * @enum {string}\n */\nconst DownloadStatus = {\n  Success: 'success',\n  Failure: 'error'\n};\n\n/**\n * Represents the download result of an audio.\n * @class\n */\nclass DownloadResult {\n\n  /**\n   * The url of the audio resource\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * AudioBuffer or Html5Audio element\n   * @type {AudioBuffer|Audio}\n   */\n  value = null;\n\n  /**\n   * Download error\n   * @type {any}\n   */\n  error = null;\n\n  /**\n   * Success or failure status of download.\n   * @type {DownloadStatus}\n   */\n  status = null;\n\n  /**\n   * @param {string|null} url The url of the audio resource\n   * @param {AudioBuffer|Audio} [value] AudioBuffer or Html5Audio element\n   * @param {*} [error] Download error\n   */\n  constructor(url, value, error) {\n    this.url = url;\n    this.value = value;\n    this.error = error || null;\n    this.status = error ? DownloadStatus.Failure : DownloadStatus.Success;\n  }\n}\n\n/**\n * Loads the audio sources into audio buffers and returns them.\n * The loaded buffers are cached.\n * @class\n */\nclass Loader {\n\n  /**\n   * AudioContext.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * In-memory audio buffer cache store.\n   * @type {object}\n   * @private\n   */\n  _bufferCache = {};\n\n  /**\n   * Dictionary to store the current progress calls and their callbacks.\n   * @type {object}\n   * @private\n   */\n  _progressCallsAndCallbacks = {};\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Create the cache.\n   * @param {AudioContext} context The Audio Context\n   */\n  constructor(context) {\n    this._context = context;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers.\n   * @param {string|string[]} urls Single or array of audio urls\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls) {\n    if (typeof urls === 'string') {\n      return this._load(urls);\n    }\n\n    return Promise.all(urls.map(url => this._load(url)));\n  }\n\n  /**\n   * Removes the cached audio buffers.\n   * @param {string|string[]} [urls] Single or array of audio urls\n   */\n  unload(urls) {\n    if (typeof urls === 'string') {\n      this._unload(urls);\n      return;\n    }\n\n    if (Array.isArray(urls)) {\n      urls.forEach(url => this._unload(url), this);\n      return;\n    }\n\n    this._bufferCache = {};\n  }\n\n  /**\n   * Dispose the loader.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.unload();\n    this._bufferCache = {};\n    this._progressCallsAndCallbacks = null;\n    this._context = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Loads a single audio resource into audio buffer and cache result if the download is succeeded.\n   * @param {string} url The Audio url\n   * @return {Promise<DownloadResult>}\n   * @private\n   */\n  _load(url) {\n    return new Promise(resolve => {\n      if (this._bufferCache.hasOwnProperty(url)) {\n        resolve(new DownloadResult(url, this._bufferCache[url]));\n        return;\n      }\n\n      if (this._progressCallsAndCallbacks.hasOwnProperty(url)) {\n        this._progressCallsAndCallbacks[url].push(resolve);\n        return;\n      }\n\n      this._progressCallsAndCallbacks[url] = [];\n      this._progressCallsAndCallbacks[url].push(resolve);\n\n      const reject = err => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, null, err)));\n        delete this._progressCallsAndCallbacks[url];\n      };\n\n      const decodeAudioData = arrayBuffer => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._context.decodeAudioData(arrayBuffer, buffer => {\n          this._bufferCache[url] = buffer;\n          this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, buffer)));\n          delete this._progressCallsAndCallbacks[url];\n        }, reject);\n      };\n\n      if (utility.isBase64(url)) {\n        const data = atob(url.split(',')[1]);\n        const dataView = new Uint8Array(data.length); // eslint-disable-line no-undef\n\n        for (let i = 0; i < data.length; ++i) {\n          dataView[i] = data.charCodeAt(i);\n        }\n\n        decodeAudioData(dataView);\n        return;\n      }\n\n      const req = new XMLHttpRequest();\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n\n      req.addEventListener('load', () => decodeAudioData(req.response), false);\n      req.addEventListener('error', reject, false);\n      req.send();\n    });\n  }\n\n  /**\n   * Removes the single cached audio buffer.\n   * @param {string} url Audio url\n   * @private\n   */\n  _unload(url) {\n    delete this._bufferCache[url];\n  }\n}\n\nexport { Loader as default, DownloadResult, DownloadStatus };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Loader.js","/**\n * Stores queue of actions that has to be run before or after specific events.\n */\nclass Queue {\n\n  _eventActions = {};\n\n  /**\n   * Queues the passed action to the event.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @param {function} action The action function.\n   * @param {boolean} [removeAfterRun = true] Remove the action once it's run.\n   */\n  add(eventName, actionIdentifier, action, removeAfterRun = true) {\n    if (!this.hasEvent(eventName)) {\n      this._eventActions[eventName] = {};\n    }\n\n    this._eventActions[eventName][actionIdentifier] = { fn: action, removeAfterRun: removeAfterRun };\n  }\n\n  /**\n   * Returns true if there is a event exists for the passed name.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   */\n  hasEvent(eventName) {\n    return this._eventActions.hasOwnProperty(eventName);\n  }\n\n  /**\n   * Returns true if the passed action is already queued-up.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @return {boolean}\n   */\n  hasAction(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return false;\n    }\n\n    return this._eventActions[eventName].hasOwnProperty(actionIdentifier);\n  }\n\n  /**\n   * Runs all the actions queued up for the passed event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  run(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return;\n    }\n\n    if (typeof actionIdentifier !== 'undefined') {\n      if (!this.hasAction(eventName, actionIdentifier)) {\n        return;\n      }\n\n      this._run(eventName, actionIdentifier);\n\n      return;\n    }\n\n    Object.keys(this._eventActions[eventName]).forEach(action => this._run(eventName, action));\n  }\n\n  /**\n   * Removes the event or a queued action for the event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  remove(eventName, actionIdentifier) {\n    if (!this._eventActions.hasOwnProperty(eventName)) {\n      return;\n    }\n\n    if (!actionIdentifier) {\n      delete this._eventActions[eventName];\n      return;\n    }\n\n    delete this._eventActions[eventName][actionIdentifier];\n  }\n\n  /**\n   * Clears all the stored events and the queued-up actions.\n   */\n  clear() {\n    this._eventActions = {};\n  }\n\n  /**\n   * Runs a single action.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @private\n   */\n  _run(eventName, actionIdentifier) {\n    const queued = this._eventActions[eventName][actionIdentifier];\n    queued.fn();\n    queued.removeAfterRun && this.remove(eventName, actionIdentifier);\n  }\n}\n\nexport default Queue;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Queue.js","/**\n * Represents a heap item.\n */\nclass HeapItem {\n\n  /**\n   * The sound object.\n   * @type {Sound}\n   */\n  sound = null;\n\n  /**\n   * The group id.\n   * @type {number|null}\n   */\n  groupId = null;\n\n  /**\n   * Set the group id and sound.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  constructor(groupId, sound) {\n    this.groupId = groupId;\n    this.sound = sound;\n  }\n}\n\n/**\n * Represents a collection of sounds belong to an audio resource.\n */\nclass HeapItemCollection {\n\n  /**\n   * The audio source url.\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * The collection of sound objects.\n   * @type {object}\n   */\n  items = {};\n\n  /**\n   * Adds a new sound item to the collection.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(groupId, sound) {\n    const soundId = sound.id().toString();\n\n    if (this.items.hasOwnProperty(soundId)) {\n      return;\n    }\n\n    this.items[soundId] = new HeapItem(groupId, sound);\n  }\n\n  /**\n   * Removes the sounds.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, groupId) {\n    Object.values(this.items).forEach(item => {\n      const { sound, soundGroupId } = item;\n\n      if(idle && (sound.isPlaying() || sound.isPaused())) {\n        return;\n      }\n\n      if (!Boolean(groupId) || soundGroupId === groupId) {\n        sound.destroy();\n        delete this.items[sound.id()];\n      }\n    });\n  }\n\n  /**\n   * Returns the sounds belong to the group or all the sounds in the collection.\n   * @param {number} [groupId] The group id.\n   * @return {Array<HeapItem>}\n   */\n  sounds(groupId) {\n    const itemsArray = Object.values(this.items);\n    const items = groupId ? itemsArray.filter(item => item.groupId === groupId) : itemsArray;\n    return items.map(item => item.sound);\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this.items).forEach(item => item.sound.destroy());\n    this.items = {};\n  }\n}\n\n/**\n * Stores all the created sounds.\n */\nclass Heap {\n\n  /**\n   * The sound collections.\n   * @type {object}\n   * @private\n   */\n  _collections = {};\n\n  /**\n   * Initialize stuff.\n   */\n  constructor() {\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Adds a new sound to the respective collection.\n   * @param {string} url The audio source url or base64 string.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(url, groupId, sound) {\n    if (!this._collections.hasOwnProperty(url)) {\n      this._collections[url] = new HeapItemCollection();\n    }\n\n    this._collections[url].add(groupId, sound);\n  }\n\n  /**\n   * Returns the sound based on the id.\n   * @param {number} id The sound id.\n   */\n  sound(id) {\n    return this.sounds().find(sound => sound.id() === id);\n  }\n\n  /**\n   * Returns the sounds belongs to a particular group or all of them.\n   * @param {number} [groupId] The group id.\n   * @return {Array}\n   */\n  sounds(groupId) {\n    const sounds = [];\n    Object.values(this._collections).forEach(col => sounds.push(...col.sounds(groupId)));\n    return sounds;\n  }\n\n  /**\n   * Removes sounds from the collections.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, groupId) {\n    Object.values(this._collections).forEach(col => col.free(idle, groupId));\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this._collections).forEach(col => col.destroy());\n    this._collections = {};\n  }\n}\n\nexport default Heap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Heap.js","import engine from './Engine';\nimport utility from './Utility';\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {string}\n */\nconst SoundState = {\n  Ready: 'ready',\n  Playing: 'playing',\n  Paused: 'paused',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Represents a sound created using Web Audio API.\n * @class\n */\nclass Sound {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current playback speed. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * The current state (playing, paused etc.) of the sound.\n   * @type {SoundState}\n   * @private\n   */\n  _state = SoundState.Ready;\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The gain node to control the volume of the sound.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * The AudioBufferSourceNode that plays the audio buffer assigned to it.\n   * @type {AudioBufferSourceNode}\n   * @private\n   */\n  _bufferSourceNode = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The playback start position.\n   * @type {number}\n   * @private\n   */\n  _startPos = 0;\n\n  /**\n   * The playback end position.\n   * @type {number}\n   * @private\n   */\n  _endPos = 0;\n\n  /**\n   * The current position of the playback.\n   * @type {number}\n   * @private\n   */\n  _currentPos = 0;\n\n  /**\n   * The position of the playback during rate change.\n   * @type {number}\n   * @private\n   */\n  _rateSeek = 0;\n\n  /**\n   * The time at which the playback started.\n   * This property is required for getting the seek position of the playback.\n   * @type {number}\n   * @private\n   */\n  _startTime = 0;\n\n  /**\n   * The callback that will be invoked after the play ends.\n   * @type {function}\n   * @private\n   */\n  _playEndCallback = null;\n\n  /**\n   * The callback that will be invoked after the sound destroyed.\n   * @type {function}\n   * @private\n   */\n  _destroyCallback = null;\n\n  /**\n   * Initializes the internal properties of the sound.\n   * @param {object} args The input parameters of the sound.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {AudioBuffer} [args.buffer] Audio source buffer.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {number} [args.startPos] The playback start position.\n   * @param {number} [args.endPos] The playback end position.\n   * @param {function} [args.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [args.destroyCallback] The callback that will be invoked after destroyed.\n   * @constructor\n   */\n  constructor(args) {\n    const {\n      id,\n      buffer,\n      volume,\n      rate,\n      loop,\n      muted,\n      startPos,\n      endPos,\n      playEndCallback,\n      destroyCallback\n    } = args;\n\n    // Set the passed id or the random one.\n    this._id = typeof id === 'number' ? id : utility.id();\n\n    // Set the passed audio buffer and duration.\n    this._buffer = buffer;\n    this._endPos = this._buffer.duration;\n\n    // Set other properties.\n    volume && (this._volume = volume);\n    rate && (this._rate = rate);\n    muted && (this._muted = muted);\n    loop && (this._loop = loop);\n    startPos && (this._startPos = startPos);\n    endPos && (this._endPos = endPos);\n    this._playEndCallback = playEndCallback;\n    this._destroyCallback = destroyCallback;\n\n    // Calculate the duration.\n    this._duration = this._endPos - this._startPos;\n\n    // Create gain node and set the volume.\n    this._context = engine.context();\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n  }\n\n  /**\n   * Plays the sound or the sound defined in the sprite.\n   * @return {Sound}\n   */\n  play() {\n    // If the sound is already playing then return.\n    if (this.isPlaying()) {\n      return this;\n    }\n\n    // Get the playback starting position.\n    let seek = Math.max(0, this._currentPos > 0 ? this._currentPos : this._startPos);\n\n    // Create a new buffersourcenode to play the sound.\n    this._bufferSourceNode = this._context.createBufferSource();\n\n    // Set the buffer, playback rate and loop parameters\n    this._bufferSourceNode.buffer = this._buffer;\n    this._bufferSourceNode.playbackRate.setValueAtTime(this._rate, this._context.currentTime);\n    this._setLoop(this._loop);\n\n    // Connect the node to the audio graph.\n    this._bufferSourceNode.connect(this._gainNode);\n\n    // Listen to the \"ended\" event to reset/clean things.\n    this._bufferSourceNode.addEventListener('ended', () => {\n      // Reset the seek positions\n      this._currentPos = 0;\n      this._rateSeek = 0;\n\n      // Destroy the node (AudioBufferSourceNodes are one-time use and throw objects).\n      this._destroyBufferNode();\n\n      // Reset the state to allow future actions.\n      this._state = SoundState.Ready;\n\n      // Invoke the callback if there is one.\n      this._playEndCallback && this._playEndCallback(this);\n    });\n\n    const startTime = this._context.currentTime;\n\n    // Call the supported method to play the sound.\n    if (typeof this._bufferSourceNode.start !== 'undefined') {\n      this._bufferSourceNode.start(startTime, seek, this._loop ? undefined : this._duration);\n    } else {\n      this._bufferSourceNode.noteGrainOn(startTime, seek, this._loop ? undefined : this._duration);\n    }\n\n    // Record the starting time and set the state.\n    this._startTime = startTime;\n    this._state = SoundState.Playing;\n\n    return this;\n  }\n\n  /**\n   * Pauses the playing sound.\n   * @return {Sound}\n   */\n  pause() {\n    // If the sound is already playing return.\n    if (!this.isPlaying()) {\n      return this;\n    }\n\n    // Save the current position and reset rateSeek.\n    this._currentPos = this.seek();\n    this._rateSeek = 0;\n\n    this._destroyBufferNode();\n\n    this._state = SoundState.Paused;\n\n    return this;\n  }\n\n  /**\n   * Stops the sound that is playing or in paused state.\n   * @return {Sound}\n   */\n  stop() {\n    // If the sound is not playing or paused return.\n    if (!this.isPlaying() && !this.isPaused()) {\n      return this;\n    }\n\n    // Reset the variables\n    this._currentPos = 0;\n    this._rateSeek = 0;\n\n    this._destroyBufferNode();\n\n    this._state = SoundState.Ready;\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound.\n   * @return {Sound}\n   */\n  mute() {\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound.\n   * @return {Sound}\n   */\n  unmute() {\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume.\n   * @param {number} [vol] Should be from 0.0 to 1.0.\n   * @return {Sound|number}\n   */\n  volume(vol) {\n    // If no input parameter is passed then return the volume.\n    // If gain node is available read and return the value from it (helps in returning accurate value during fading)\n    // or else delegate that to the derived type.\n    if (typeof vol === 'undefined') {\n      return this._volume;\n    }\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the playback rate.\n   * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n   * @return {Sound|number}\n   */\n  rate(rate) {\n    // If no input parameter is passed return the current rate.\n    if (typeof rate === 'undefined') {\n      return this._rate;\n    }\n\n    this._rate = rate;\n    this._rateSeek = this.seek();\n\n    if (this.isPlaying()) {\n      this._startTime = this._context.currentTime;\n      this._bufferSourceNode && (this._bufferSourceNode.playbackRate.setValueAtTime(rate, this._context.currentTime));\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the seek position.\n   * @param {number} [seek] The seek position.\n   * @return {Sound|number}\n   */\n  seek(seek) {\n    // If no parameter is passed return the current position.\n    if (typeof seek === 'undefined') {\n      const realTime = this.isPlaying() ? this._context.currentTime - this._startTime : 0;\n      const rateElapsed = this._rateSeek ? this._rateSeek - this._currentPos : 0;\n\n      return this._currentPos + (rateElapsed + realTime * this._rate);\n    }\n\n    // If seeking outside the borders then return.\n    if (seek < this._startPos || seek > this._endPos) {\n      return this;\n    }\n\n    // If the sound is currently playing... pause it, set the seek position and then continue playing.\n    const isPlaying = this.isPlaying();\n\n    if (isPlaying) {\n      this.pause();\n    }\n\n    this._currentPos = seek;\n\n    if (isPlaying) {\n      this.play();\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the loop parameter of the sound.\n   * @param {boolean} [loop] True to loop the sound.\n   * @return {Sound/boolean}\n   */\n  loop(loop) {\n    if (typeof loop !== 'boolean') {\n      return this._loop;\n    }\n\n    this._loop = loop;\n    this._setLoop(loop);\n\n    return this;\n  }\n\n  /**\n   * Destroys the dependencies and release the memory.\n   * @return {Sound}\n   */\n  destroy() {\n    // If the sound is already destroyed return.\n    if (this._state === SoundState.Destroyed) {\n      return this;\n    }\n\n    // Stop the sound.\n    this.stop();\n\n    this._gainNode.disconnect();\n\n    this._buffer = null;\n    this._context = null;\n    this._gainNode = null;\n\n    // Set the state to \"destroyed\".\n    this._state = SoundState.Destroyed;\n\n    this._destroyCallback && this._destroyCallback(this);\n\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns whether the sound is muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the sound.\n   * @return {SoundState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the total duration of the playback.\n   * @return {number}\n   */\n  duration() {\n    return this._duration;\n  }\n\n  /**\n   * Returns true if the buzz is playing.\n   * @return {boolean}\n   */\n  isPlaying() {\n    return this._state === SoundState.Playing;\n  }\n\n  /**\n   * Returns true if buzz is paused.\n   * @return {boolean}\n   */\n  isPaused() {\n    return this._state === SoundState.Paused;\n  }\n\n  /**\n   * Returns the gain node.\n   * @return {GainNode}\n   */\n  _gain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Stops the playing buffer source node and destroys it.\n   * @private\n   */\n  _destroyBufferNode() {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    if (typeof this._bufferSourceNode.stop !== 'undefined') {\n      this._bufferSourceNode.stop();\n    }\n    else {\n      this._bufferSourceNode.noteGrainOff();\n    }\n\n    this._bufferSourceNode.disconnect();\n    this._bufferSourceNode.removeEventListener('ended', this._onEnded);\n    this._bufferSourceNode = null;\n  }\n\n  /**\n   * Sets the sound to play repeatedly or not.\n   * @param {boolean} loop True to play the sound repeatedly.\n   * @private\n   */\n  _setLoop(loop) {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    this._bufferSourceNode.loop = loop;\n\n    if (loop) {\n      this._bufferSourceNode.loopStart = this._startPos;\n      this._bufferSourceNode.loopEnd = this._endPos;\n    }\n  }\n}\n\nexport { Sound as default, SoundState };\n\n\n\n// WEBPACK FOOTER //\n// ./src/Sound.js","import engine, { ErrorType } from './Engine';\nimport Queue from './Queue';\nimport utility from './Utility';\nimport emitter from './Emitter';\nimport { DownloadStatus } from './Loader';\n\n/**\n * Enum that represents the different states of a sound group (buzz).\n * @enum {string}\n */\nconst BuzzState = {\n  Ready: 'ready',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Enum that represents the different events fired by a buzz.\n * @enum {string}\n */\nconst BuzzEvents = {\n  Load: 'load',\n  UnLoad: 'unload',\n  PlayStart: 'playstart',\n  PlayEnd: 'playend',\n  Pause: 'pause',\n  Stop: 'stop',\n  Volume: 'volume',\n  Mute: 'mute',\n  Seek: 'seek',\n  Rate: 'rate',\n  Error: 'error',\n  Destroy: 'destroy'\n};\n\n/**\n * Enum that represents the different states occurs while loading a sound.\n * @enum {string}\n */\nconst LoadState = {\n  NotLoaded: 'notloaded',\n  Loading: 'loading',\n  Loaded: 'loaded'\n};\n\n/**\n * A wrapper class that simplifies dealing with group of sounds.\n */\nclass Buzz {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @protected\n   */\n  _id = -1;\n\n  /**\n   * Represents the source of the sound. The source can be an url or base64 string.\n   * @type {*}\n   * @protected\n   */\n  _src = null;\n\n  /**\n   * The formats of the passed audio sources.\n   * @type {Array<string>}\n   * @protected\n   */\n  _format = [];\n\n  /**\n   * The sprite definition.\n   * @type {object}\n   * @protected\n   */\n  _sprite = null;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @protected\n   */\n  _volume = 1.0;\n\n  /**\n   * The current rate of the playback. Should be from 0.5 to 5.\n   * @type {number}\n   * @protected\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @protected\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @protected\n   */\n  _loop = false;\n\n  /**\n   * True to pre-loaded the sound on construction.\n   * @type {boolean}\n   * @protected\n   */\n  _preload = false;\n\n  /**\n   * True to auto-play the sound on construction.\n   * @type {boolean}\n   * @protected\n   */\n  _autoplay = false;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @protected\n   */\n  _duration = 0;\n\n  /**\n   * The best compatible source in the audio sources passed.\n   * @type {string|null}\n   * @protected\n   */\n  _compatibleSrc = null;\n\n  /**\n   * Represents the different states that occurs while loading the sound.\n   * @type {LoadState}\n   * @protected\n   */\n  _loadState = LoadState.NotLoaded;\n\n  /**\n   * Represents the state of this group.\n   * @type {BuzzState}\n   * @private\n   */\n  _state = BuzzState.Ready;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The audio engine.\n   * @type {Engine}\n   * @private\n   */\n  _engine = null;\n\n  /**\n   * Initializes the internal properties.\n   * @param {string|Array<string>|object} args The input parameters of this sound group.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {string|string[]} args.src Single or array of audio urls/base64 strings.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {boolean} [args.preload = false] True to pre-load the sound after construction.\n   * @param {boolean} [args.autoplay = false] True to play automatically after construction.\n   * @param {string|string[]} [args.format] The file format(s) of the passed audio source(s).\n   * @param {object} [args.sprite] The sprite definition.\n   * @param {function} [args.onload] Event-handler for the \"load\" event.\n   * @param {function} [args.onunload] Event-handler for the \"unload\" event.\n   * @param {function} [args.onplaystart] Event-handler for the \"playstart\" event.\n   * @param {function} [args.onplayend] Event-handler for the \"playend\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onrate] Event-handler for the \"rate\" event.\n   * @param {function} [args.onseek] Event-handler for the \"seek\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondestroy] Event-handler for the \"destroy\" event.\n   * @constructor\n   */\n  constructor(args) {\n    // Setup the audio engine.\n    this._engine = engine;\n    this._engine.setup();\n\n    // If no audio is available throw error.\n    if (!this._engine.isAudioAvailable()) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    if (typeof args === 'string') {\n      this._src = [args];\n    } else if (Array.isArray(args) && args.length) {\n      this._src = args;\n    } else if (typeof args === 'object') {\n      const {\n        id,\n        src,\n        format,\n        sprite,\n        volume,\n        rate,\n        muted,\n        loop,\n        autoplay,\n        preload,\n        onload,\n        onunload,\n        onplaystart,\n        onplayend,\n        onstop,\n        onpause,\n        onmute,\n        onvolume,\n        onrate,\n        onseek,\n        onerror,\n        ondestroy\n      } = args;\n\n      // Set the passed id or the random one.\n      this._id = typeof id === 'number' ? id : utility.id();\n\n      // Set the source.\n      if (typeof src === 'string') {\n        this._src = [src];\n      } else if(Array.isArray(src) && src.length) {\n        this._src = src;\n      }\n\n      // Set the format.\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      // Set other properties.\n      typeof sprite === 'object' && (this._sprite = sprite);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (this._rate = rate);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof loop === 'boolean' && (this._loop = loop);\n      typeof autoplay === 'boolean' && (this._autoplay = autoplay);\n      typeof preload === 'boolean' && (this._preload = preload);\n      typeof onload === 'function' && this.on(BuzzEvents.Load, onload);\n      typeof onunload === 'function' && this.on(BuzzEvents.UnLoad, onunload);\n\n      // Bind the passed event handlers to events.\n      typeof onplaystart === 'function' && this.on(BuzzEvents.PlayStart, onplaystart);\n      typeof onplayend === 'function' && this.on(BuzzEvents.PlayEnd, onplayend);\n      typeof onstop === 'function' && this.on(BuzzEvents.Stop, onstop);\n      typeof onpause === 'function' && this.on(BuzzEvents.Pause, onpause);\n      typeof onmute === 'function' && this.on(BuzzEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(BuzzEvents.Volume, onvolume);\n      typeof onrate === 'function' && this.on(BuzzEvents.Rate, onrate);\n      typeof onseek === 'function' && this.on(BuzzEvents.Seek, onseek);\n      typeof onerror === 'function' && this.on(BuzzEvents.Error, onerror);\n      typeof ondestroy === 'function' && this.on(BuzzEvents.Destroy, ondestroy);\n    }\n\n    // Throw error if source is not passed.\n    if (!this._src) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    // Instantiate the dependencies.\n    this._queue = new Queue();\n\n    if (this._autoplay) {\n      this.play();\n    } else if (this._preload) {\n      this.load();\n    }\n  }\n\n  /**\n   * Loads the sound to the underlying audio object.\n   * @return {Buzz}\n   */\n  load() {\n    // If the sound is already loaded return without reloading again.\n    if (this.isLoaded() || this._loadState === LoadState.Loading) {\n      return this;\n    }\n\n    // Set the state to \"Loading\" to avoid loading multiple times.\n    this._loadState = LoadState.Loading;\n\n    // Get the compatible source.\n    const src = this._compatibleSrc || (this._compatibleSrc = this.getCompatibleSource());\n\n    // If no compatible source found call failure method and return.\n    if (!src) {\n      this._onLoadFailure('The audio formats you passed are not supported');\n      return this;\n    }\n\n    // Load the audio source.\n    this._engine.load(src).then(downloadResult => {\n      // During the time of loading... if the buzz is unloaded or destroyed then return.\n      if (this._loadState === LoadState.NotLoaded || this._state === BuzzState.Destroyed) {\n        return;\n      }\n\n      // If loading succeeded,\n      // i. Save the result.\n      // ii. Set the load state as loaded.\n      // iii. Fire the load event.\n      // iv. Run the methods that are queued to run after successful load.\n      if (downloadResult.status === DownloadStatus.Success) {\n        this._buffer = downloadResult.value;\n        this._duration = this._buffer.duration;\n        this._loadState = LoadState.Loaded;\n        this._fire(BuzzEvents.Load, null, downloadResult);\n        this._queue.run('after-load');\n        return;\n      }\n\n      this._onLoadFailure(downloadResult.error);\n    });\n\n    return this;\n  }\n\n  /**\n   * Called on failure of loading audio source.\n   * @param {*} error The audio source load error.\n   * @protected\n   */\n  _onLoadFailure(error) {\n    // Remove the queued actions from this class that are supposed to run after load.\n    this._queue.remove('after-load');\n\n    // Set the load state back to not loaded.\n    this._loadState = LoadState.NotLoaded;\n\n    // Fire the error event.\n    this._fire(BuzzEvents.Error, null, { type: ErrorType.LoadError, error: error });\n  }\n\n  /**\n   * Returns the first compatible source based on the passed sources and the format.\n   * @return {string}\n   */\n  getCompatibleSource() {\n    // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n    return this._format.length ?\n      this._src[this._format.indexOf(utility.getSupportedFormat(this._format))] :\n      utility.getSupportedSource(this._src);\n  }\n\n  /**\n   * Plays the passed sound defined in the sprite or the sound that belongs to the passed id.\n   * @param {string|number} [soundOrId] The sound name defined in sprite or the sound id.\n   * @return {Buzz|number}\n   */\n  play(soundOrId) {\n    const isIdPassed = typeof soundOrId === 'number';\n\n    // If id is passed then get the sound from the engine and play it.\n    if (isIdPassed) {\n      const sound = this._engine.sound(soundOrId);\n\n      if (sound) {\n        sound.play();\n        this._fire(BuzzEvents.PlayStart, soundOrId);\n      }\n\n      return this;\n    }\n\n    const newSoundId = utility.id(),\n      playSound = () => {\n        const soundArgs = {\n          id: newSoundId,\n          buffer: this._buffer,\n          volume: this._volume,\n          rate: this._rate,\n          muted: this._muted,\n          loop: this._loop,\n          playEndCallback: sound => this._fire(BuzzEvents.PlayEnd, sound.id()),\n          destroyCallback: sound => {\n            this._fire(BuzzEvents.Destroy, sound.id());\n            emitter.clear(sound.id());\n          }\n        };\n\n        if (typeof soundOrId === 'string' && this._sprite && this._sprite.hasOwnProperty(soundOrId)) {\n          const positions = this._sprite[soundOrId];\n          soundArgs.startPos = positions[0];\n          soundArgs.endPos = positions[1];\n        }\n\n        const newSound = this._engine.sound(this._compatibleSrc, this._id, soundArgs);\n        newSound.play();\n\n        this._fire(BuzzEvents.PlayStart, newSound.id());\n      };\n\n    // If the sound is not yet loaded push an action to the queue to play the sound once it's loaded.\n    if (!this.isLoaded()) {\n      this._queue.add('after-load', `play-${newSoundId}`, () => playSound());\n      this.load();\n    } else {\n      playSound();\n    }\n\n    return newSoundId;\n  }\n\n  /**\n   * Pauses the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  pause(id) {\n    this._queue.remove('after-load', id ? `play-${id}` : null);\n    this._sounds(id).forEach(sound => sound.pause());\n    this._fire(BuzzEvents.Pause, id);\n\n    return this;\n  }\n\n  /**\n   * Stops the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  stop(id) {\n    this._queue.remove('after-load', id ? `play-${id}` : null);\n    this._sounds(id).forEach(sound => sound.stop());\n    this._fire(BuzzEvents.Stop, id);\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  mute(id) {\n    this._sounds(id).forEach(sound => sound.mute());\n    typeof id !== 'number' && (this._muted = true);\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  unmute(id) {\n    this._sounds(id).forEach(sound => sound.unmute());\n    typeof id !== 'number' && (this._muted = false);\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume of the passed sound or the group.\n   * @param {number} [volume] Should be from 0.0 to 1.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  volume(volume, id) {\n    if (typeof volume === 'number' && volume >= 0 && volume <= 1.0) {\n      this._sounds(id).forEach(sound => sound.volume(volume));\n      typeof id !== 'number' && (this._volume = volume);\n      this._fire(BuzzEvents.Volume, id, this._volume);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.volume() : null;\n    }\n\n    return this._volume;\n  }\n\n  /**\n   * Gets/sets the rate of the passed sound or the group.\n   * @param {number} [rate] Should be from 0.5 to 5.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  rate(rate, id) {\n    if (typeof rate === 'number' && rate >= 0.5 && rate <= 5) {\n      this._sounds(id).forEach(sound => sound.rate(rate));\n      typeof id !== 'number' && (this._rate = rate);\n      this._fire(BuzzEvents.Rate, id, this._rate);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.rate() : null;\n    }\n\n    return this._rate;\n  }\n\n  /**\n   * Gets/sets the current playback position of the sound.\n   * @param {number} id The sound id\n   * @param {number} [seek] The seek position.\n   * @return {Buzz|number}\n   */\n  seek(id, seek) {\n    const sound = this._engine.sound(id);\n\n    if (!sound) {\n      return this;\n    }\n\n    if (typeof seek === 'number') {\n      // If the audio source is not yet loaded push an item to the queue to seek after the sound is loaded\n      // and load the sound.\n      if (!this.isLoaded()) {\n        this._queue.add('after-load', `seek-${id}`, () => this.seek(id, seek));\n        this.load();\n        return this;\n      }\n\n      sound.seek(seek);\n      this._fire(BuzzEvents.Seek, id, seek);\n      return this;\n    }\n\n    return sound.seek();\n  }\n\n  /**\n   * Gets/sets the looping behavior of a sound or the group.\n   * @param {boolean} [loop] True to loop the sound.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|boolean}\n   */\n  loop(loop, id) {\n    if (typeof loop === 'boolean') {\n      this._sounds(id).forEach(sound => sound.loop(loop));\n      typeof id !== 'number' && (this._loop = loop);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.loop() : null;\n    }\n\n    return this._loop;\n  }\n\n  /**\n   * Returns true if the passed sound is playing.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  playing(id) {\n    const sound = this._engine.sound(id);\n    return sound ? sound.isPlaying() : null;\n  }\n\n  /**\n   * Returns true if the passed sound is muted or the group is muted.\n   * @param {number} [id] The sound id.\n   * @return {boolean}\n   */\n  muted(id) {\n    if(typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.muted() : null;\n    }\n\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the passed sound or the group.\n   * @return {BuzzState|SoundState}\n   */\n  state(id) {\n    if(typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.state() : null;\n    }\n\n    return this._state;\n  }\n\n  /**\n   * Returns the duration of the passed sound or the total duration of the sound.\n   * @param {number} [id] The sound id.\n   * @return {number}\n   */\n  duration(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.duration() : null;\n    }\n\n    return this._duration;\n  }\n\n  /**\n   * Unloads the loaded audio buffer.\n   * @return {Buzz}\n   */\n  unload() {\n    this._queue.remove('after-load');\n    this._engine.unload(this._compatibleSrc);\n    this._buffer = null;\n    this._duration = 0;\n    this._loadState = LoadState.NotLoaded;\n    return this;\n  }\n\n  /**\n   * Stops and destroys all the sounds belong to this group and release other dependencies.\n   */\n  destroy() {\n    if (this._state === BuzzState.Destroyed) {\n      return this;\n    }\n\n    this.stop();\n    this._queue.clear();\n    this._engine.free(false, this._id);\n\n    this._buffer = null;\n    this._queue = null;\n    this._engine = null;\n    this._state = BuzzState.Destroyed;\n\n    this._fire(BuzzEvents.Destroy);\n\n    emitter.clear(this._id);\n  }\n\n  /**\n   * Subscribes to an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {boolean} [once = false] True for one-time event handling.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  on(eventName, handler, once = false, id) {\n    emitter.on(id || this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  off(eventName, handler, id) {\n    emitter.off(id || this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns the audio resource loading status.\n   * @return {LoadState}\n   */\n  loadState() {\n    return this._loadState;\n  }\n\n  /**\n   * Returns true if the audio source is loaded.\n   * @return {boolean}\n   */\n  isLoaded() {\n    return this._loadState === LoadState.Loaded;\n  }\n\n  /**\n   * Returns the sound for the passed id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this._engine.sound(id);\n  }\n\n  /**\n   * Returns true if the passed sound exists.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  alive(id) {\n    return Boolean(this.sound(id));\n  }\n\n  /**\n   * Returns the sound for the passed id or all the sounds belong to this group.\n   * @param {number} [id] The sound id.\n   * @return {Array<Sound>}\n   * @private\n   */\n  _sounds(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? [sound] : [];\n    }\n\n    return this._engine.sounds(this._id);\n  }\n\n  /**\n   * Fires an event of group or sound.\n   * @param {string} eventName The event name.\n   * @param {number} [id] The sound id.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Buzz}\n   * @private\n   */\n  _fire(eventName, id, ...args) {\n    if (id) {\n      emitter.fire(id, eventName, ...args, this.sound(id), this);\n    } else {\n      emitter.fire(this._id, eventName, ...args, this);\n    }\n\n    return this;\n  }\n}\n\nconst $buzz = args => new Buzz(args);\n[\n  'setup',\n  'load',\n  'unload',\n  'mute',\n  'unmute',\n  'volume',\n  'stop',\n  'suspend',\n  'resume',\n  'terminate',\n  'muted',\n  'state',\n  'context',\n  'isAudioAvailable',\n  'on',\n  'off'\n].forEach(method => {\n  $buzz[method] = function () {\n    const result = engine[method](...arguments);\n    return result === engine ? $buzz : result;\n  };\n});\n\nmodule.exports = $buzz;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Buzz.js"],"sourceRoot":""}